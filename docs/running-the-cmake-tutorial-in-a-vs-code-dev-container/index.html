<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Running the CMake Tutorial in a VS Code Dev Container &mdash; CodeSolid.com 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=19645805"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex/" />
    <link rel="search" title="Search" href="../search/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../" class="icon icon-home">
            CodeSolid.com
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Featured Articles:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../using-latex-in-python/">Using LaTeX In Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installing-pyenv-on-a-mac/">Installing Pyenv on a Mac (A Setup Guide With Usage Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../conda-vs-pip/">Conda vs. Pip, Venv, and Pyenv – Simplicity Wins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../jupyter-password/">Jupyter Password: Easy Notebook and Lab Configuration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Added Recently:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting-started-with-ollama/">Getting Started With Ollama</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/yet-another-jdesmos-demo/">Yet Another JDesmos Demo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/desmos-jupyter/">Using Desmos Graphs in Jupyter Notebooks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Categories</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../category-math-and-math-software/">Math and Math Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-python-for-beginners-posts/">Python for Beginners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-python-functions/">Python Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-python-math-and-science/">Python Math and Science</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-python-practice/">Python Practice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-python-tools/">Python Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-pandas/">Pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-miscellaneous/">Other</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-docker/">Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-jupyter/">Jupyter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../category-learn-to-code/">Learn to Code</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../">CodeSolid.com</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Running the CMake Tutorial in a VS Code Dev Container</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/running-the-cmake-tutorial-in-a-vs-code-dev-container.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="running-the-cmake-tutorial-in-a-vs-code-dev-container">
<h1>Running the CMake Tutorial in a VS Code Dev Container<a class="headerlink" href="#running-the-cmake-tutorial-in-a-vs-code-dev-container" title="Link to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>Though frequent readers of this blog will know that it’s been focused largely on Python until now, I recently decided to revisit the two languages I started my career with some thirty-three years ago: C and C++. Even after many years, C and C++ are still quite popular languages. As of July 2023, Python, C, and C++ are the three most popular languages in the TIOBE index. Though I’m impressed with Rust, and its popularity is rising, as a blogger, I hesitate to commit too much time to a language that is still relatively unpopular.</p>
<p>Moreover, C and C++ complement the Python focus of this blog very nicely. What we usually think of as Python – CPython – is written in C, and many familiar C extensions, such as NumPy, make heavy use of optimized C code. (The same is beginning to be true of Rust with libraries such as PolaRS, but the use of C extensions in Python is much more widespread).</p>
<p>Broadly speaking, compared to Python, C/C++ are two languages that are significantly faster than Python and much more widely used in system programming and embedded programming. The cost for this runtime speed is a steeper learning curve and greater programmer responsibility for memory management and other “low-level” concerns that Python handles automatically.</p>
</section>
<section id="limits-of-c-c-for-cross-platform-development">
<h2>Limits of C/C++ for Cross-Platform Development<a class="headerlink" href="#limits-of-c-c-for-cross-platform-development" title="Link to this heading"></a></h2>
<p>One such concern that strikes you right away is that C/C++ programs need to be explicitly compiled and linked in a separate step, tasks that take place transparently when you run Python scripts through the interpreter. Unlike in Python, moreover, the tools to do this are different depending on your environment. With rare exceptions, the Python executable works pretty much the same across all platforms, whereas in the C/C++ world, this is not the case. Linux developers use gcc to compile their programs along with other third-party make tools to build their programs. Since GCC does not work on Apple Silicon, developers there are locked in for now to a choice between Clang or XCode. On Windows, developers frequently use Visual Studio, Microsoft’s development tool for C/C++, and other languages.</p>
<p>As you might have guessed already, this variety of different tools would be something of a disadvantage to developers targeting multiple platforms. To mitigate this disadvantage, a number of cross-platform build tools have been created over the years that attempt to automatically do the right thing for whatever target platform you’re on. One of the most popular of these tools is CMake, which is widely used for many open-source packages and widely supported across a number of IDEs, including Visual Studio, XCode, and CLion.</p>
</section>
<section id="a-special-use-case">
<h2>A Special Use Case<a class="headerlink" href="#a-special-use-case" title="Link to this heading"></a></h2>
<p>In addition to wanting to explore and master CMake, I also wanted to be in a position to try some simple embedded programming projects, especially using a Microbit processor. From my earlier explorations with Rust, I discovered that this really would be <a class="reference external" href="https://rustassured.com/embedded-rust-development-on-apple-silicon-mac-m1/" title="much easier to do if the gdb debugger were available">much easier to do if GDB were available</a> (it’s not on Apple silicon, i.e., M1/M2-based systems).</p>
<p>With this in mind, even though I could run the CMake tutorial (without GDB, of course) on a Mac without issues, I decided to try my hand at building CMake from source in a Docker container. This would – in principle – allow me to use the same development setup to eventually work on embedded projects directly from the Mac without spring for an expensive upgrade for my aging Windows and Linux hardware.</p>
<p>The rest of this article details how I did this, which you may find useful as a refresher on some Docker techniques. For those of you who’d rather cut to the chase and already know your way around Docker, you can use the containers we’ll build here directly if you wish. I’ve pushed the final container to Dockerhub as codesolid/gcc_make_tutorial, so you can pull it from there directly. The code for this article is located in the repository <a class="reference external" href="https://github.com/codesolid/c">https://github.com/codesolid/c</a>.</p>
</section>
<section id="first-steps-building-cmake-from-source-in-docker">
<h2>First Steps: Building CMake from Source in Docker<a class="headerlink" href="#first-steps-building-cmake-from-source-in-docker" title="Link to this heading"></a></h2>
<p>My first step was to locate a Linux-based container with the gcc compiler already installed and add CMake to that container. One of the more reliable ways to install CMake is to build and install it from the source. Though somewhat slower than installing a package, this method has the advantage of also picking up the tutorial source that we want to use in a subsequent step. Rather than have a long series of run commands in the Dockerfile, I decided to move a lot of the install steps to a shell script and simply call it. Here’s the shell script I used:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="c1"># File: install_cmake.sh</span>
<span class="c1"># Installs CMake on Linux</span>

<span class="nv">CMAKE_VERSION</span><span class="o">=</span><span class="s2">&quot;3.27.0&quot;</span>

<span class="c1"># Skip if already installed.</span>
<span class="k">if</span><span class="w"> </span>!<span class="w"> </span><span class="nb">command</span><span class="w"> </span>-v<span class="w"> </span>cmake<span class="w"> </span><span class="p">&amp;</span>&gt;<span class="w"> </span>/dev/null
<span class="k">then</span>
<span class="w">    </span>mkdir<span class="w"> </span>/cmake-source
<span class="w">    </span><span class="nb">cd</span><span class="w"> </span>/cmake-source/
<span class="w">    </span>wget<span class="w"> </span>https://github.com/Kitware/CMake/archive/refs/tags/v<span class="nv">$CMAKE_VERSION</span>.tar.gz
<span class="w">    </span>tar<span class="w"> </span>xfvz<span class="w"> </span>v<span class="nv">$CMAKE_VERSION</span>.tar.gz
<span class="w">    </span><span class="nb">cd</span><span class="w"> </span>CMake-<span class="nv">$CMAKE_VERSION</span>/
<span class="w">    </span>./bootstrap
<span class="w">    </span>make<span class="w"> </span>
<span class="w">    </span>make<span class="w"> </span>install
<span class="k">fi</span>
</pre></div>
</div>
<p>The associated Dockerfile thus becomes fairly lightweight, consisting mostly of copying and running the shell script:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># Dockerfile</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">gcc:latest</span>
<span class="k">COPY</span><span class="w"> </span>./install_cmake.sh<span class="w"> </span>.
<span class="k">RUN</span><span class="w"> </span>chmod<span class="w"> </span>u+x<span class="w"> </span>./install_cmake.sh<span class="w"> </span>
<span class="k">RUN</span><span class="w"> </span>./install_cmake.sh
</pre></div>
</div>
<p>Building from the CMake source takes a few minutes. This command does the trick:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>codesolid/gcc_cmake<span class="w"> </span>.<span class="w"> </span>
</pre></div>
</div>
<p>If desired, we can test that the CMake install did the right thing.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>-it<span class="w"> </span>codesolid/gcc_cmake<span class="w"> </span>/bin/bash
cmake<span class="w"> </span>--version
</pre></div>
</div>
</section>
<section id="isolating-the-tutorial-source-with-a-multi-stage-build">
<h2>Isolating the Tutorial Source With a Multi-Stage Build<a class="headerlink" href="#isolating-the-tutorial-source-with-a-multi-stage-build" title="Link to this heading"></a></h2>
<p>Now that we’ve worked through the basics of installing CMake only, we decided to rewrite (ahem: “iteratively enhance”) our project to use a multi-stage Docker build that also installs the source.</p>
<p>In our install_cmake shell script, the only change we need is to remove the hard-coded CMake version. Instead, we now accept the version number as an argument, as follows:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="o">[</span><span class="w"> </span><span class="nv">$#</span><span class="w"> </span>-eq<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">]</span>
<span class="k">then</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;No arguments supplied&quot;</span>
<span class="w">    </span><span class="nb">exit</span><span class="w"> </span><span class="m">0</span>
<span class="k">fi</span>

<span class="nv">CMAKE_VERSION</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>Our Dockerfile is almost all brand new, however. We add code to move the tutorial source to a more convenient directory, remove the rest of the CMake source code since we’ll no longer need it, and install gdb for good measure.</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># Build/install CMake as before</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">gcc:latest</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">gcc_cmake</span>
<span class="k">ENV</span><span class="w"> </span><span class="nv">CMAKE_VERSION</span><span class="o">=</span><span class="m">3</span>.27.0
<span class="k">COPY</span><span class="w"> </span>./install_cmake.sh<span class="w"> </span>.
<span class="k">RUN</span><span class="w"> </span>chmod<span class="w"> </span>u+x<span class="w"> </span>./install_cmake.sh<span class="w"> </span>
<span class="k">RUN</span><span class="w"> </span>./install_cmake.sh<span class="w"> </span><span class="si">${</span><span class="nv">CMAKE_VERSION</span><span class="si">}</span>

<span class="c"># Copy the source to a more convenient directory</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">gcc_cmake</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="s">gcc_cmake_tutorial</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/source</span>
<span class="k">RUN</span><span class="w"> </span>cp<span class="w"> </span>-R<span class="w"> </span>/cmake-source/CMake-<span class="si">${</span><span class="nv">CMAKE_VERSION</span><span class="si">}</span>/Help/guide/tutorial/*<span class="w"> </span>/source

<span class="c"># Clean up source and install gdb so it&#39;s available.</span>
<span class="k">RUN</span><span class="w"> </span>rm<span class="w"> </span>-rf<span class="w"> </span>/cmake-source
<span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>update<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>gdb<span class="w"> </span>-y
</pre></div>
</div>
<p>You can build the container with this command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>codesolid/gcc_make_tutorial<span class="w"> </span>.
</pre></div>
</div>
<p>If you’d prefer to see all the output and not just the truncated log message, you can build it as shown below. (This can be useful if you need to troubleshoot the execution or if you’re just wondering what it’s doing all this time).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>buildx<span class="w"> </span>create<span class="w"> </span>--use<span class="w"> </span>--name<span class="w"> </span>larger_log<span class="w"> </span>--driver-opt<span class="w"> </span>env.BUILDKIT_STEP_LOG_MAX_SIZE<span class="o">=</span><span class="m">50000000</span>

docker<span class="w"> </span>buildx<span class="w"> </span>build<span class="w">  </span>--progress<span class="w"> </span>plain<span class="w"> </span>-t<span class="w"> </span>codesolid/gcc_cmake_tutorial<span class="w"> </span>.
</pre></div>
</div>
</section>
<section id="accessing-the-tutorial-from-the-container-and-the-host">
<h2>Accessing the Tutorial from the Container and the Host<a class="headerlink" href="#accessing-the-tutorial-from-the-container-and-the-host" title="Link to this heading"></a></h2>
<section id="creating-a-volume-in-a-local-directory-and-mounting-it">
<h3>Creating a Volume in a Local Directory and Mounting It<a class="headerlink" href="#creating-a-volume-in-a-local-directory-and-mounting-it" title="Link to this heading"></a></h3>
<p>In order to access the source code and keep it available from one run to the next, even if we stop the container, we need to do more than pass a simple volume to the run command. Instead, we create a permanent volume mapped to a local “source” directory. This is a one-time operation:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>-p<span class="w"> </span>./source
docker<span class="w"> </span>volume<span class="w"> </span>create<span class="w"> </span>--driver<span class="w"> </span><span class="nb">local</span><span class="w"> </span><span class="se">\</span>
<span class="w">      </span>--opt<span class="w"> </span><span class="nv">type</span><span class="o">=</span>none<span class="w"> </span><span class="se">\</span>
<span class="w">      </span>--opt<span class="w"> </span><span class="nv">device</span><span class="o">=</span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span>/source<span class="w"> </span><span class="se">\</span>
<span class="w">      </span>--opt<span class="w"> </span><span class="nv">o</span><span class="o">=</span><span class="nb">bind</span><span class="w"> </span><span class="se">\</span>
<span class="w">      </span>gcc_make_tutorial_source
</pre></div>
</div>
<p>That done, we can now use the –mount switch in the docker run command to mount a volume in the container to the volume on the host that we created in our last step.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>--rm<span class="w"> </span>-it<span class="w"> </span>--name<span class="w"> </span>tutorial<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>--mount<span class="w"> </span><span class="nv">type</span><span class="o">=</span>volume,src<span class="o">=</span>gcc_make_tutorial_source,target<span class="o">=</span>/source<span class="w"> </span><span class="se">\</span>
<span class="w">    </span>codesolid/gcc_cmake_tutorial<span class="w"> </span>/bin/bash
</pre></div>
</div>
<p>This will bring up a bash prompt in the container. You can verify that the mounting was successful and the files are available on both the container and the host by comparing the contents of a directory. For example, on the container:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>root@c3aa841b06c8:/source#<span class="w"> </span><span class="nb">pwd</span>
/source
root@c3aa841b06c8:/source#<span class="w"> </span>ls<span class="w"> </span>Step5
CMakeLists.txt<span class="w">  </span>MathFunctions<span class="w">  </span>TutorialConfig.h.in<span class="w">  </span>tutorial.cxx
root@c3aa841b06c8:/source#<span class="w"> </span>
</pre></div>
</div>
<p>On the host:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">(</span>base<span class="o">)</span><span class="w"> </span><span class="nb">source</span><span class="w"> </span>%<span class="w"> </span><span class="nb">pwd</span>
/Users/johnlockwood/source/CodeSolid/c/gcc_cmake_tutorial/source
<span class="o">(</span>base<span class="o">)</span><span class="w"> </span><span class="nb">source</span><span class="w"> </span>%<span class="w"> </span>ls<span class="w"> </span>Step5<span class="w">                    </span>
CMakeLists.txt<span class="w">          </span>MathFunctions<span class="w">           </span>TutorialConfig.h.in<span class="w">     </span>tutorial.cxx
<span class="o">(</span>base<span class="o">)</span><span class="w"> </span><span class="nb">source</span><span class="w"> </span>%<span class="w"> </span>
</pre></div>
</div>
<p>Note that we want to leave this container running so we can use it in the next section.</p>
</section>
</section>
<section id="using-vs-code-s-dev-container-extension">
<h2>Using VS Code’s Dev Container Extension<a class="headerlink" href="#using-vs-code-s-dev-container-extension" title="Link to this heading"></a></h2>
<p>Rather than be limited to editing the code from VS Code on the host, the VS Code “Dev Containers” extension lets you connect to either a pre-existing Dev Container developed by Microsoft or attach to a running container you’ve developed yourself. We’ll show the latter case here, but it’s worth mentioning that the Visual Studio Dev Container for C++ includes CMake (though not the tutorial source, as far as I’m aware).</p>
<p>With the Dev Container extension installed, as with most extensions, you use the Command Pallete (CMD-SHIFT-P or CTRL-SHIFT-P) to access the extension’s features. If you start typing “Dev”, you can search for and run the command labeled “Dev Containers: Attach to Running Container”:</p>
<p><img alt="" src="../_images/image5.png" /></p>
<p>Here you’ll see your running tutorial container in the list of available containers.</p>
<p><img alt="" src="../_images/image-118.png" /></p>
<p>Selecting it will open a new VS Code window, opening the source folder on the container. From here, if you open a terminal, it will automatically be a terminal in the container, not on the host. If you open a C++ file, it may prompt you to install an additional extension (as you’d expect if you were working on the host).</p>
<p><img alt="" src="../_images/image-2-1024x768.png" /></p>
<p>Using the Dev Containers plugin with the C++ Extension Pack, I discovered that it does just what I want it to do. That is, it lets me build and debug code on the container from within VS Code. To demonstrate this, I’ve checked the code for the tutorial solutions I’ve worked on so far in <a class="reference external" href="https://github.com/CodeSolid/c/tree/main/cmake_tutorial_solutions">this repository folder</a>. (If you’ve been following along in the gcc_cmake_tutorial folder, that’s fine – simply copy the repository folder’s source to the source folder in gcc_cmake_tutorial).</p>
<p>If you have the tutorial solution files in place, you can open a terminal prompt in the VS Code window that’s attached to the dev container. Create a source/Step_2 folder if you don’t have one already, and from that directory, run these commands to build the Step 2 project in debug mode:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>cmake<span class="w"> </span>-DCMAKE_BUILD_TYPE<span class="o">=</span>Debug<span class="w"> </span>../Step2
cmake<span class="w"> </span>--build<span class="w"> </span>.
</pre></div>
</div>
<p>What this does is create a debug symbol table and link it to the executable so that, for example, we can step through our code in the debugger. Before we do this, however, we have a couple of quick things to do. First, we need a launch configuration for VS Code. To do this, from the Run menu, select “Open Configurations”. This should open the file launch.json. Here’s the configuration that I have, so if your file is more or less blank, you can just copy this in as-is:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Use IntelliSense to learn about possible attributes.</span>
<span class="w">    </span><span class="c1">// Hover to view descriptions of existing attributes.</span>
<span class="w">    </span><span class="c1">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span>
<span class="w">    </span><span class="nt">&quot;version&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;0.2.0&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;configurations&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">        </span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="nt">&quot;name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;(gdb) Launch Step 2 Tutorial&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;cppdbg&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;request&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;launch&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;program&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;${workspaceRoot}/Step2_build/Tutorial&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;args&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;16&quot;</span><span class="p">],</span>
<span class="w">            </span><span class="nt">&quot;stopAtEntry&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;cwd&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;${fileDirname}&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;environment&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[],</span>
<span class="w">            </span><span class="nt">&quot;externalConsole&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;MIMode&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;gdb&quot;</span><span class="p">,</span>
<span class="w">            </span><span class="nt">&quot;setupCommands&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="nt">&quot;description&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Enable pretty-printing for gdb&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="nt">&quot;text&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;-enable-pretty-printing&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="nt">&quot;ignoreFailures&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">                </span><span class="p">},</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="nt">&quot;description&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Set Disassembly Flavor to Intel&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="nt">&quot;text&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="p">,</span>
<span class="w">                    </span><span class="nt">&quot;ignoreFailures&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">]</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main things that were edited here from a default “(gdb) Launch” configuration are:</p>
<ul class="simple">
<li><p>The name, which we’ve associated with Step 2 so as not to confuse it with the default or other configurations.</p></li>
<li><p>The program line, which points to the executable we just built.</p></li>
<li><p>The args line, where we pass the number 16 to our square root function. I know you probably already know the answer to the square root of 16, but of course, we’re here to have fun debugging, not to prove the math.</p></li>
</ul>
<p>We’re almost there. Let’s open the file Step2/tutorial.cxx in the editor. We’re now should be ready to launch the debugger, and it should prompt you for the launch configuration we just created. If it doesn’t, or you run into errors, try this: select the correct launch configuration manually. To do this, choose the settings button (see the gear icon) in the upper right-hand corner. It should look something like this with the button pressed:</p>
<p><img alt="Selecting a launch configuration in VS Code." src="../_images/image-4-1024x337.png" /></p>
<p>You may have to scroll, but in the image above, note that the “(gdb) Launch Step 2 Tutorial” configuration is at the bottom, so just select it. Annoyingly, this opens the configuration file again, but it also selects it as current.</p>
<p>You can now use the debugger as you normally would on your own machine. For example, you can set a breakpoint in the first line of the main method, and clicking the start button (upper right) will land you here:</p>
<p><img alt="Debugging C++ in a custom container using the VS Code Dev container plugin." src="../_images/image-5-1024x466.png" /></p>
<p>Of course, you have the usual fun variables, watch, and call stack windows over on the left. If debugging C++ or other languages is new to you and you’d like to see a tutorial on it, drop me a comment, and I’ll add it to my to-do list.</p>
<p>If you work in VS Code and like to have the flexibility of being able to browse and debug source in pre-built development environments that others can install easily, I urge you to check out the Dev Containers plugin in VS Code. My experience to date shows me it works flawlessly for C++, and unlike the Docker support in some commercial IDEs – it’s 100% free! I’m confident it probably runs well for other languages as well. As for me, I’m off to do more chapters of the CMake tutorial and start experimenting with my own projects using it.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, John Lockwood.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QX7KGT4YPE"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-QX7KGT4YPE', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>