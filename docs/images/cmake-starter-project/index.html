<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; CodeSolid.com 0.1 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/documentation_options.js?v=19645805"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex/" />
    <link rel="search" title="Search" href="../../search/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../" class="icon icon-home">
            CodeSolid.com
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Featured Articles:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../using-latex-in-python/">Using LaTeX In Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installing-pyenv-on-a-mac/">Installing Pyenv on a Mac (A Setup Guide With Usage Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../conda-vs-pip/">Conda vs. Pip, Venv, and Pyenv – Simplicity Wins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../jupyter-password/">Jupyter Password: Easy Notebook and Lab Configuration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Categories</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../category-c-and-cplusplus/">C and C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-docker/">Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-jupyter/">Jupyter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-learn-to-code/">Learn to Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-math-and-math-software/">Math and Math Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-math/">Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-miscellaneous/">Other</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-newsletter/">Newsletter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-pandas/">Pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-for-beginners-posts/">Python for Beginners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-functions/">Python Funcitons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-math-and-science/">Python Math and Science</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-practice/">Header</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-tools/">Python Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python/">Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../all_files/">Site Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../">CodeSolid.com</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/images/cmake-starter-project/index.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>Table of Contents</p>
<ul class="simple">
<li><p>Introduction</p></li>
<li><p>Part I: A Brief Review of the CMake Tutorial</p></li>
<li><p>What You’ll Learn in Part Two</p></li>
<li><p>The CMake Starter Project: A Test First Approach</p></li>
<li><p>Building and Running Our Tests</p></li>
<li><p>Adding a Library</p></li>
<li><p>Adding an Application with a Library Dependency</p></li>
<li><p>Closing Thoughts and Next Steps</p></li>
<li><p>Get the Code</p></li>
</ul>
<section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Link to this heading">¶</a></h1>
<p>This article is a follow-on to my recent article, <a class="reference external" href="https://codesolid.com/running-the-cmake-tutorial-in-a-vs-code-dev-container/">Running the CMake Tutorial in a VS Code Container</a>. Toward the end of that tutorial, we built one of the tutorial steps and debugged it in a VS Code container. Since then, I’ve finished the tutorial and published my <a class="reference external" href="https://github.com/CodeSolid/c/tree/main/cmake_tutorial_solutions">solutions set</a>, in case you’re looking for one of those.</p>
<p>My purpose in the present article is twofold. First, if you’re on the verge of working through the tutorial yourself or have just slogged through it, I’ll share my experiences with it in a brief review. We’ll see that the tutorial has some limitations, so we’ll need to dig further into the tool to become more proficient with it. The best way to do that is to actually create a CMake build system for a simple (but flexible) starter project. We’ll do that step by step in the second part of the article.</p>
<p>Of course, I have a project of my own in mind, but I’ll resist the urge to get too far into that code, providing just enough detail so you can easily swap out that code with a project of your own.</p>
</section>
<section id="part-i-a-brief-review-of-the-cmake-tutorial">
<h1>Part I: A Brief Review of the CMake Tutorial<a class="headerlink" href="#part-i-a-brief-review-of-the-cmake-tutorial" title="Link to this heading">¶</a></h1>
<p>CMake’s tutorial does a pretty good job of walking you through a lot of the basic CMake properties and functions you’ll need to work with the tool to create libraries and executables (and link them, of course), and it does a fair job of introducing some advanced features like supporting installers, using generator expressions, etc. It’s broken down into a series of steps, each of which consists of a number of exercises. Generally, the exercises point you to the CMake documentation for the functions you’ll need to use, but a hidden section reveals the full code you need if you can’t work it out from the documentation.</p>
<p>For all but the simplest examples, however, this “point them to the documentation” approach suffers from a drawback of the documentation itself, that of not providing sufficient usage examples to be helpful on its own.</p>
<p>A more serious limitation is that there isn’t much discussion of how to work with third-party libraries (beyond the C++ standard library, of course). CMake is a build tool generator, of course, and not a package manager, but it does have some facilities for downloading and building packages. The most modern (and self-contained) of these are provided by the FetchContent module.</p>
<p>Because I’ve drunk a little too deeply over the years from the pitcher of TDD Kool-Aid, the first thing I want to do when creating a new project structure is to set up a way to run unit tests. The CMake tutorial does show you how to do this – so that’s good – but it shows you how to do this as integrated tests you write run from CMake against the main executable. Of course, you can figure out how to use the tools it teaches to integrate with other test systems, but what I really want to know is how to write my tests in a C++ file and build them in CMake like a regular human. Writing tests in a build tool is a lot like jumping off a cliff into the ocean: it’s nice to know it’s an option if murderers are chasing you in a movie, but that hardly makes it a best practice.</p>
<p>Finally, the tool does not go into much depth on best practices around setting up a project. One could argue that that’s not a tutorial’s job. To be sure, it contains a library and an executable, so there’s a starting point for that sort of thing, but many of the best practices enabled by recent enhancements to CMake have been left out. Of course, before working to create a more complex starter project, I wanted to explore some of those best practices. This article has been influenced especially by two resources:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://cliutils.gitlab.io/modern-cmake/" title="An Introduction to Modern CMake">An Introduction to Modern CMake</a> – This is a great overall resource on managing third-party packages. Also, it offers an opinionated sample project structure that I found useful enough as a starting point. It’s light on code, though, so providing that inspired this article.</p></li>
<li><p><a class="reference external" href="https://crascit.com/2016/01/31/enhanced-source-file-handling-with-target_sources/" title="Enhanced source file handling with target_sources">Enhanced Source File Handling with target_sources</a> – Once you’ve selected a structure for your multi-directory project, this article is well worth consulting for how to keep it from getting difficult to manage.</p></li>
</ul>
</section>
<section id="what-you-ll-learn-in-part-two">
<h1>What You’ll Learn in Part Two<a class="headerlink" href="#what-you-ll-learn-in-part-two" title="Link to this heading">¶</a></h1>
<p>By the end of this tutorial:</p>
<ul class="simple">
<li><p>You’ll know how to set up a multi-folder CMake project, including a build directory containing debug and release builds, and how to automate the process of building. We’ll beg the question a bit here with a plain Makefile (for Gnu Make) (i.e., one different from one that the CMake build process generates as part of the build).</p></li>
<li><p>We’ll present a flexible method for including and building any CMake-compatible source that’s hosted in a GitHub repository (or other public repository). We won’t use Conan or other “package repositories” since the universe of open-source CMake projects on GitHub is far larger than the recipes listed on Conan.io (probably the largest such package repository).</p></li>
<li><p>We’ll illustrate the above points using the Catch2 unit test framework. However, the technique we show here will work with any framework, so you certainly could if you wanted to substitute GoogleTest (for example). We’ll also add a test target to our “external” Makefile.</p></li>
<li><p>Once we have testing in place, we’ll externalize our one test function to a library, which can also be linked to our main application, which we’ll also develop.</p></li>
</ul>
</section>
<section id="the-cmake-starter-project-a-test-first-approach">
<h1>The CMake Starter Project: A Test First Approach<a class="headerlink" href="#the-cmake-starter-project-a-test-first-approach" title="Link to this heading">¶</a></h1>
<p>Beginning from a plain directory, let’s consider what we need. We want to keep our root directory relatively clean with our main CMakeLists.txt project file, our Makefile helper, a README, and our .gitignore file.</p>
<p>Next, simplifying somewhat the suggested structure in the Introduction to Modern CMake site we mentioned earlier, we’ll build out a similar directory structure:</p>
<ul class="simple">
<li><p>root project directory</p>
<ul>
<li><p>test</p></li>
<li><p>build</p></li>
<li><p>lib</p></li>
<li><p>app</p></li>
</ul>
</li>
</ul>
<p>Of course, this structure may grow over time, but it’ll do for now. If it’s not obvious what goes where our unit tests will go in test, our main header file and library source will go in lib, our program using the library will go into the app directory, and all our artifacts will go into the build directory and subdirectories of it.</p>
<p>Let’s get started by focusing on our Main CMakeLists.txt file and the test directory. Our root CMakeLists.txt file first:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># source_root/CMakeLists.txt</span>

cmake_minimum_required<span class="o">(</span>VERSION<span class="w"> </span><span class="m">3</span>.24<span class="o">)</span>
project<span class="o">(</span>Starter<span class="w"> </span>VERSION<span class="w"> </span><span class="m">0</span>.01<span class="o">)</span>

set<span class="o">(</span>CMAKE_CXX_STANDARD<span class="w"> </span><span class="m">17</span><span class="o">)</span>
set<span class="o">(</span>CMAKE_CXX_STANDARD_REQUIRED<span class="w"> </span>True<span class="o">)</span>

<span class="c1"># Test first</span>
add_executable<span class="o">(</span>tests<span class="w"> </span><span class="s2">&quot;&quot;</span><span class="o">)</span>

add_subdirectory<span class="o">(</span><span class="nb">test</span><span class="o">)</span>
</pre></div>
</div>
<p>Outside of the comment (mainly for this article), the first two things we need are really boilerplate to make CMake work at all – a cmake_minimum_required statement and a project name and version. We’re so-very-creatively calling our starter project “Starter”, and our version number is quite humbly low.</p>
<p>The order of the next two lines (and the other lines we’ll be adding here) is important. In particular, any add_executable or add_library function calls <em>must</em> come <em>before</em> the corresponding add_subdirectory call. The reason for this is that the subdirectory’s CMakeLists.txt file’s job is to configure the target’s sources, dependencies, and so forth by the name we gave it when we added it, and if we haven’t added it yet, that’s bad. The clue will be CMake complaining that you’re trying to do something to a target that’s “not built by this project”.</p>
<p>Now let’s create our test directory and add this file to it:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># test/CMakeLists.txt</span>

target_sources<span class="o">(</span>tests
<span class="w">    </span>PRIVATE
<span class="w">        </span>test.cpp
<span class="o">)</span>

include<span class="o">(</span>FetchContent<span class="o">)</span>
FetchContent_Declare<span class="o">(</span>
<span class="w">  </span>Catch2
<span class="w">  </span>GIT_REPOSITORY<span class="w"> </span>git@github.com:catchorg/Catch2.git
<span class="w">  </span>GIT_TAG<span class="w">        </span>4acc51828f7f93f3b2058a63f54d112af4034503<span class="w"> </span><span class="c1"># devel branch v. 3, as of 8/3/2023</span>
<span class="o">)</span>

FetchContent_MakeAvailable<span class="o">(</span>Catch2<span class="o">)</span>
target_link_libraries<span class="o">(</span>tests<span class="w"> </span>PRIVATE<span class="w"> </span>Catch2::Catch2WithMain<span class="o">)</span>
</pre></div>
</div>
<p>This isn’t too long yet, but there’s a fair amount going on that we should stop to consider. First, note the target_sources command that was highlighted in one of the articles we mentioned earlier. We’re saying that the “tests” executable that we added in our root file will have one PRIVATE source file, test.cpp. (“PRIVATE” in the context is a bit redundant for a test executable, but CMake syntax requires it).</p>
<p>Next, we’re going to declare and build our first external dependency. We include the FetchContent module, then make two calls:</p>
<ul class="simple">
<li><p>FetchContent_Declare takes a name, a repository, and a tag, branch, or commit name (labeled by GIT_TAG in any case).</p></li>
<li><p>FetchContent_MakeAvailable actually does the fetching and building of this project.</p></li>
</ul>
<p>Once we have the dependency “installed and built” in our CMake environment, we need to link our tests executable to one of the targets it exports. The first part of the name is consistent with what we used in our FetchContent calls. You’ll need to consult the project itself to see what it exports. In this case, “Catch2::Catch2WithMain” means we won’t need a main function in our test code since Catch2 gives us one that will do the right thing.</p>
<p>That’s all we need from a build perspective, but notice we need said we need a source file named test.cpp. To get one, we’re going to shamelessly copy the “hello-world” style Catch2 tutorial file:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;catch2/catch_test_macros.hpp&gt;</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Factorial</span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Factorial</span><span class="p">(</span><span class="n">number</span><span class="mi">-1</span><span class="p">)</span><span class="o">*</span><span class="n">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">TEST_CASE</span><span class="p">(</span><span class="w"> </span><span class="s">&quot;Factorials are computed&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;[factorial]&quot;</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">REQUIRE</span><span class="p">(</span><span class="w"> </span><span class="n">Factorial</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">REQUIRE</span><span class="p">(</span><span class="w"> </span><span class="n">Factorial</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">REQUIRE</span><span class="p">(</span><span class="w"> </span><span class="n">Factorial</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="p">);</span>
<span class="w">    </span><span class="n">REQUIRE</span><span class="p">(</span><span class="w"> </span><span class="n">Factorial</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3628800</span><span class="w"> </span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>There’s not much mystery here. The REQUIRE macro basically asserts that the boolean expression is true and halts the test case on failure. (To print the failure without halting the test, use CHECK). A benefit of Catch2 is that the boolean expression is just any C++ code you want. You don’t need to learn a set of matchers like EXPECT_MY_PUPPY_TO_BE_NAMED_BORIS. To be sure, this is just a toy example, and the limited range of these tests actually hides a bug (as we’ll demonstrate later). Moreover, this test case with essentially four asserts might give unit test purists the one-test-per-function vapors, but to paraphrase Mark Antony, “We come here to build this code, not to praise it.”</p>
</section>
<section id="building-and-running-our-tests">
<h1>Building and Running Our Tests<a class="headerlink" href="#building-and-running-our-tests" title="Link to this heading">¶</a></h1>
<p>So with that, let’s be about building and running the tests. For now, let’s do our first build from the command line. (I’m working on a Mac, and the same command line works for Linux. We’ll address making the code from this section truly cross-platform in a future post. Meantime, all our code and CMakeLists.txt will work on Windows as well.)</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>-p<span class="w"> </span>build/Debug
<span class="nb">cd</span><span class="w"> </span>build/Debug
cmake<span class="w"> </span>-DCMAKE_BUILD_TYPE<span class="o">=</span>Debug<span class="w"> </span>../..<span class="w"> </span>
cmake<span class="w"> </span>--build<span class="w"> </span>.
</pre></div>
</div>
<p>Next, let’s test run our tests. While still within the build/Debug directory in the project root, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./tests
</pre></div>
</div>
<p>You should see something like this, but of course, the random seed will be different:</p>
<p><img alt="" src="../../_images/image4.png" /></p>
<p>At this point, we realize this project has a working set of unit tests, so we may have something good going on here. Let’s build a utility Makefile for our environment so we won’t have to remember all that stuff above:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Main project builder</span>

.PHONY:<span class="w"> </span>build<span class="w"> </span><span class="nb">test</span><span class="w"> </span>clean

build:
<span class="w">	</span>mkdir<span class="w"> </span>-p<span class="w"> </span>build/Release
<span class="w">	</span>mkdir<span class="w"> </span>-p<span class="w"> </span>build/Debug
<span class="w">	</span><span class="nb">cd</span><span class="w"> </span>build/Debug<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>cmake<span class="w"> </span>-DCMAKE_BUILD_TYPE<span class="o">=</span>Debug<span class="w"> </span>../..<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>cmake<span class="w"> </span>--build<span class="w"> </span>.
<span class="w">	</span><span class="nb">cd</span><span class="w"> </span>build/Release<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>cmake<span class="w"> </span>-DCMAKE_BUILD_TYPE<span class="o">=</span>Release<span class="w"> </span>../..<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>cmake<span class="w"> </span>--build<span class="w"> </span>.

<span class="c1"># Note this also cleans the third-party libraries we&#39;ve built.  This could be more fine-grained to improve build times.</span>
clean:
<span class="w">	</span>rm<span class="w"> </span>-rf<span class="w"> </span>build

<span class="c1"># Run the test</span>
test:<span class="w"> </span>
<span class="w">	</span>./build/Debug/tests<span class="w"> </span>

<span class="c1"># Show tests that pass too</span>
test-verbose:<span class="w"> </span>
<span class="w">	</span>./build/Debug/tests<span class="w"> </span>-s
</pre></div>
</div>
<p>I like to keep the output clean, but you can easily make the test depend on the build, like this if desired:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>test:<span class="w"> </span>build
<span class="w">	</span>./build/Debug/tests
</pre></div>
</div>
<p>Now without leaving the root, you can use “<code class="docutils literal notranslate"><span class="pre">make</span></code>” (default target is the same as <code class="docutils literal notranslate"><span class="pre">&quot;make</span> <span class="pre">build,&quot;</span></code> since it’s the first target), “<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span></code>” to run the tests, etc.</p>
</section>
<section id="adding-a-library">
<h1>Adding a Library<a class="headerlink" href="#adding-a-library" title="Link to this heading">¶</a></h1>
<p>At this stage, we have a working build and some unit tests, but it’s still just a toy project. Having the code and the tests together like this is perhaps useful while you’re working out new ideas in development (as we’ve done here), but really what we want is to have the tests consume a library. Then the tests we develop will help us maintain any executables that we (or others) link to the same library.</p>
<p>As a first step, let’s change our CMakeLists.txt file to look like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># source_root/CMakeLists.txt</span>

cmake_minimum_required<span class="o">(</span>VERSION<span class="w"> </span><span class="m">3</span>.24<span class="o">)</span>
project<span class="o">(</span>Starter<span class="w"> </span>VERSION<span class="w"> </span><span class="m">0</span>.01<span class="o">)</span>

set<span class="o">(</span>CMAKE_CXX_STANDARD<span class="w"> </span><span class="m">17</span><span class="o">)</span>
set<span class="o">(</span>CMAKE_CXX_STANDARD_REQUIRED<span class="w"> </span>True<span class="o">)</span>

<span class="c1"># Add libraries and executables first, </span>
<span class="c1"># before add_subdirectory calls</span>
add_library<span class="o">(</span>lib<span class="o">)</span>
add_executable<span class="o">(</span>tests<span class="w"> </span><span class="s2">&quot;&quot;</span><span class="o">)</span>

add_subdirectory<span class="o">(</span>lib<span class="o">)</span>
add_subdirectory<span class="o">(</span><span class="nb">test</span><span class="o">)</span>
</pre></div>
</div>
<p>Since our last version, we’ve added two lines, both having to do with the “lib” library, <code class="docutils literal notranslate"><span class="pre">add_library</span></code> and <code class="docutils literal notranslate"><span class="pre">add_subdirectory</span></code>. What’s important is that we keep all the <code class="docutils literal notranslate"><span class="pre">add_subdirectory</span></code> calls at the end, but the order within each section doesn’t matter. We’ve added the library first, though, as a way of documenting that the executable will depend on it.</p>
<p>Next, let’s build out the library itself. Make a directory off the root called lib. You should now have a root directory that looks like this:</p>
<p><img alt="Root directory from &quot;tree -L&quot; after adding the lib directory." src="../../_images/image-112.png" /></p>
<p>In the lib directory, let’s start by creating a cpp file, lib.cpp: We’ll simply move the Factorial definition from root/test/test.cpp, and include a header for it. Here’s how that looks:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;lib.h&quot;</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Factorial</span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Factorial</span><span class="p">(</span><span class="n">number</span><span class="mi">-1</span><span class="p">)</span><span class="o">*</span><span class="n">number</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In root/test.cpp, we also need to add this line at the top beneath our other header:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;lib.h&gt;</span>
</pre></div>
</div>
<p>Next, we need to build that header file with the function prototype:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">Factorial</span><span class="p">(</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
<p>Now that we’ve changed our root CMake CMakeLists.txt and the source code, we need a CMakeLists.txt file in the lib directory, too! Here’s that file:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># lib/CMakeLists.txt</span>

target_sources<span class="o">(</span>lib
<span class="w">    </span>PUBLIC
<span class="w">      </span>lib.h
<span class="w">    </span>PRIVATE
<span class="w">      </span>lib.cpp
<span class="o">)</span>

target_include_directories<span class="o">(</span>lib<span class="w"> </span>INTERFACE<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">CMAKE_CURRENT_SOURCE_DIR</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>We make the lib.cpp file private since other targets don’t need to include it. For the header, we make it public and add the line below it:</p>
<p><code class="docutils literal notranslate"><span class="pre">target_include_directories(lib</span> <span class="pre">INTERFACE</span> <span class="pre">&quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;)</span></code></p>
<p>I may have been somewhat critical of the CMake tutorials earlier, but I now confess that I looked this trick up in the Tutorial code I worked on when I initially had to figure out why the test wasn’t building because of the include. To fix that, you need the code so far and one less step. We add a line to link to the library above the existing target_link_libraries call, as shown below:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1">#Add this line to test/CMakeLists.txt:</span>
target_link_libraries<span class="o">(</span>tests<span class="w"> </span>PRIVATE<span class="w"> </span>lib<span class="o">)</span>

target_link_libraries<span class="o">(</span>tests<span class="w"> </span>PRIVATE<span class="w"> </span>Catch2::Catch2WithMain<span class="o">)</span>
</pre></div>
</div>
<p>At this point, we can run “<code class="docutils literal notranslate"><span class="pre">make</span></code>” and “<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">test</span></code>” again and everything should build and work as it did before.</p>
</section>
<section id="adding-an-application-with-a-library-dependency">
<h1>Adding an Application with a Library Dependency<a class="headerlink" href="#adding-an-application-with-a-library-dependency" title="Link to this heading">¶</a></h1>
<p>Given where we are, with the tests depending on the library, adding another target doing the same thing is a simple matter of creating a new directory and reworking things a bit using techniques we’ve already mastered. First, we create the app directory underneath the project root. In it, we add a short new CMakeLists.txt file</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># app/CMakeLists.txt</span>

target_sources<span class="o">(</span>factorial
<span class="w">    </span>PRIVATE
<span class="w">        </span>app.cpp
<span class="o">)</span>

target_link_libraries<span class="o">(</span>factorial<span class="w"> </span>PRIVATE<span class="w"> </span>lib<span class="o">)</span>
</pre></div>
</div>
<p>We also add the app.cpp file that’s mentioned in CMakeLists.txt as a target source:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// app/app.cpp</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;lib.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">argv</span><span class="p">[])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Usage: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span>
<span class="w">            </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; number&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;! = &quot;</span><span class="w"> </span>
<span class="w">        </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">Factorial</span><span class="p">(</span><span class="n">input</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the target_sources and target_link_libraries calls in the CMakeLists.txt file here to work, the target we’re referencing has to exist, of course, so we modify the root CMakeLists.txt file, adding the following two lines:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># source_root/CMakeLists.txt</span>

<span class="c1"># ...</span>
<span class="c1"># Add this at the end of the add_library and add_executable section</span>
add_executable<span class="o">(</span>factorial<span class="w"> </span><span class="s2">&quot;&quot;</span><span class="o">)</span>

<span class="c1"># ...</span>
<span class="c1"># Add this as the last line in the file:</span>
add_subdirectory<span class="o">(</span>app<span class="o">)</span>
</pre></div>
</div>
<p>We can now build and test out our app from the command line:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>make

./build/Debug/factorial
Usage:<span class="w"> </span>./build/Debug/factorial<span class="w"> </span>number

<span class="c1"># A little math notation in the output</span>
./build/Debug/factorial<span class="w"> </span><span class="m">3</span>
<span class="m">3</span>!<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">6</span><span class="w"> </span>

<span class="c1"># Here&#39;s the bug we mentioned earlier.  After a certain point </span>
<span class="c1"># (likely machine dependent and perhaps involving integer overflow), this happens:</span>
/build/Debug/factorial<span class="w"> </span><span class="m">33</span>
<span class="m">33</span>!<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2147483648</span>

./build/Debug/factorial<span class="w"> </span><span class="m">34</span>
<span class="m">34</span>!<span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>
</pre></div>
</div>
<p>Of course, the bug in our library is not our concern. The contents of the library code, our test code, and our app code are all just there as stubs so we can test that our CMake build script works and runs correctly.</p>
</section>
<section id="closing-thoughts-and-next-steps">
<h1>Closing Thoughts and Next Steps<a class="headerlink" href="#closing-thoughts-and-next-steps" title="Link to this heading">¶</a></h1>
<p>In our use of the FetchContent module and functions in test/CMakeLists.txt, we’ve seen a straightforward method for consuming pinned dependencies from CMake. We’ve learned not only how to separate a library from its executable dependencies (a topic covered, after all, in the CMake tutorial), but we’ve also shown how to keep the main (root) CMake file minimal, making each target’s directory CMake file responsible for whatever that target needs to build.</p>
<p>There are several next steps you might take, some of which we may also cover here in follow-on articles. For example:</p>
<ul class="simple">
<li><p>We pointed out that our utility Makefile is not really cross-platform. Moreover, it relies on Gnu Make, a separate download everywhere but on Linux. One possibility would be to script a series of [CMake cross-platform commands](http://Run a Command-Line Tool) and process it with <code class="docutils literal notranslate"><span class="pre">CMake</span> <span class="pre">-P</span></code>. Another would be to either document the CMake steps and just run them (which is tedious) or to create a separate utility file for bash and windows batch (or Powershell).</p></li>
<li><p>We only demonstrated how to use FetchContent on one dependency, Catch2. Your library project is sure to need many more of its own. Generally, separating these out as needed is a good thing, but there is an interesting corner case to consider. There may be certain code that you want to test (for example, the code that parses configuration files or command line arguments for your application). You might not want this in your library since external clients don’t care about it, but linking the tests to an executable will not work. Different solutions to this include testing the executable code manually (i.e., by running the application), creating a separate “UI utility” library, or excluding the code from your public library that your app and test suite use by creating two targets against the same directory.</p></li>
<li><p>There are other alternatives to FetchContent that we haven’t considered here. Many developers, including the author of the Modern CMake article (cited earlier), are fond of Git submodules. It may be, however, that the packages you need can all be found on conan.io. If that’s the case, you might find this <a class="reference external" href="https://github.com/conan-io/cmake-conan" title="CMake Conan plugin useful">CMake Conan plugin</a> to be useful. Either way, it might also be useful to separate the dependencies out as a separate target since our current “make clean” command forces a rebuild of everything, even the dependencies. This is not ideal from the perspective of having a relatively clean build that’s also fast.</p></li>
<li><p>The Isabella Muerte quote in our top-of-page featured image certainly applies to the issue of different dependency sources and methods, but it also applies to build tools. We’ve been writing about CMake first since it’s most popular in the C and C++ world, but there is a lot of buzz around <a class="reference external" href="https://mesonbuild.com/">Meson</a> in particular.</p></li>
</ul>
</section>
<section id="get-the-code">
<h1>Get the Code<a class="headerlink" href="#get-the-code" title="Link to this heading">¶</a></h1>
<p>The code for this article is hosted on GitHub in the cmake_starter folder of <a class="reference external" href="https://github.com/CodeSolid/c">https://github.com/CodeSolid/c</a>.</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, John Lockwood.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QX7KGT4YPE"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-QX7KGT4YPE', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>