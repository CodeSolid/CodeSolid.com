<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Is Docker Important for Python Development &mdash; CodeSolid.com 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=19645805"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex/" />
    <link rel="search" title="Search" href="../../search/" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../" class="icon icon-home">
            CodeSolid.com
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search/" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Featured Articles:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../using-latex-in-python/">Using LaTeX In Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installing-pyenv-on-a-mac/">Installing Pyenv on a Mac (A Setup Guide With Usage Tips)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../conda-vs-pip/">Conda vs. Pip, Venv, and Pyenv – Simplicity Wins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../jupyter-password/">Jupyter Password: Easy Notebook and Lab Configuration</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Categories</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../category-c-and-cplusplus/">C and C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-docker/">Docker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-jupyter/">Jupyter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-learn-to-code/">Learn to Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-math-and-math-software/">Math and Math Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-math/">Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-miscellaneous/">Other</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-newsletter/">Newsletter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-pandas/">Pandas</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-for-beginners-posts/">Python for Beginners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-functions/">Python Funcitons</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-math-and-science/">Python Math and Science</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-practice/">Header</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python-tools/">Python Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../category-python/">Python</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">More:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../all_files/">Site Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../">CodeSolid.com</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Is Docker Important for Python Development</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/images/how-to-use-docker-with-python/index.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p>Docker and Python are two great tools that work great together to simplify the development and deployment of an application. Most of my readers are naturally already quite familiar with Python, and I’m sure most are familiar with Docker, but if you’re not, don’t worry.</p>
<p>The answer to can you use Docker with Python is that you most certainly can, and it’s not complicated. Docker allows you to bundle an image – similar to a virtual machine but more lightweight – along with whatever code you wish to ship. Hence, it’s an excellent platform for running Python processes.</p>
<p>This tutorial teaches you how to use Docker with Python. We’ll start with the basics and work through several examples, using docker, the command-line client for the Docker daemon (server), and docker-compose, a tool for building, combining, and networking containers together in various ways.</p>
<p>Python Docker Examples Source Code</p>
<p>Table of Contents</p>
<ul class="simple">
<li><p>Is Docker Important for Python Development</p></li>
<li><p>First Steps: Installing and Configuring Docker</p></li>
<li><p>Basic Docker Concepts</p></li>
<li><p>Running Python Flask in a Docker Container</p></li>
<li><p>Selecting a Base Docker Image for Python</p></li>
<li><p>A Simple Flask Dockerfile</p></li>
<li><p>Building and Running the Flask Image and Python Docker Container</p></li>
<li><p>Running Django and Postgres Using Docker Compose</p>
<ul>
<li><p>A Django And Docker-Compose Starter Application</p></li>
<li><p>A docker-compose.yaml file for Postgres and Django</p></li>
<li><p>The Django Dockerfile and Source</p></li>
<li><p>Some Django Utility Scripts for Docker</p></li>
<li><p>A Simple Django Dockerfile</p></li>
<li><p>Putting It All Together</p></li>
</ul>
</li>
<li><p>More Useful Docker Commands</p></li>
<li><p>Closing Thoughts</p></li>
</ul>
<section id="is-docker-important-for-python-development">
<h1>Is Docker Important for Python Development<a class="headerlink" href="#is-docker-important-for-python-development" title="Link to this heading"></a></h1>
<p>Getting started with docker-compose python is not hard. However, before getting into the how of using Docker and Docker-Compose with Python perhaps it makes sense to take a step back and think about the why.</p>
<p>Docker is important for Python development because it is a tool that makes development environments easy to automate on local and remote machines. It also allows the creation of containers that can run in almost any environment including all major cloud vendors and on-premise environments as well.</p>
<p>Moreover, the popularity of Kubernetes and the fact that it is so widely supported by different vendors means the definition of Cloud Native Computing frequently gets associated with Docker and Kubernetes, a fact that the Wikipedia entry acknowledges as well:</p>
<blockquote>
<div><p>Frequently, cloud-native applications are built as a set of microservices that run in Docker containers, and may be orchestrated in Kubernetes…The advantage of using Docker containers is the ability to package all software needed to execute into one executable package. The container runs in a virtualized environment, which isolates the contained application from its environment.</p>
<p>https://en.wikipedia.org/wiki/Cloud_native_computing</p>
</div></blockquote>
<p>All this taken together means that a small investment in mastering Docker is likely to pay substantial dividends throughout your Python career.</p>
</section>
<section id="first-steps-installing-and-configuring-docker">
<h1>First Steps: Installing and Configuring Docker<a class="headerlink" href="#first-steps-installing-and-configuring-docker" title="Link to this heading"></a></h1>
<p>I recommend having Docker installed and ready to work with before you begin to get the most out of this article. If you don’t already have it, visit the <a class="reference external" href="https://docs.docker.com/get-docker/">Get Docker</a> page to install it. Once you’ve installed Docker, you should be able to go through the Get Started guide, or for the impatient, try going to a command line prompt and running:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>hello-world
</pre></div>
</div>
<p>You should see Docker downloading something and a long message that includes “Hello from Docker!” If that works, you’re ready to go! If that doesn’t work for you, some possible solutions are:</p>
<ul class="simple">
<li><p>Find the docker application on your system and ensure the Docker Desktop application has started. This will ensure the Docker daemon (background process) is running.</p></li>
<li><p>If you see a permissions issue, as you might, especially on Linux, see the optional post-installation steps for running Docker without sudo.</p></li>
<li><p>You may be prompted at some point to create a dockerhub account. Another name for <a class="reference external" href="https://hub.docker.com">hub.docker.</a><a class="reference external" href="https://hub.docker.com">com</a>, dockerhub is a repository for sharing public and private docker images. It’s the Docker equivalent of PyPi.org in the Python world.</p></li>
</ul>
<p>If those steps don’t get you up and running, you can try the time-honored “paste the error message into Google.” Docker is popular and well supported, so that’s quite likely to turn up the answer.</p>
</section>
<section id="basic-docker-concepts">
<h1>Basic Docker Concepts<a class="headerlink" href="#basic-docker-concepts" title="Link to this heading"></a></h1>
<p>Let’s begin with some basic docker concepts and terminology we’ll encounter along the way. As we mentioned before, docker is a combination of two command-line clients and a server (the Docker daemon). Together they allow us to run “containers,” which you can think of as processes that are isolated from the main process space of your computer but are nevertheless much more lightweight and faster than virtual machines.</p>
<p>A Docker container is a running instance of a Docker image. An image, in turn, is a template for building up a set of layers that work together and can be used to run a container. We build an image template from a Docker source file (usually named Dockerfile). The Dockerfile specifies a parent image such as an operating system or other public dockerhub images as a base. In our case, this will be a combination of an operating system and a Python distribution. You can then install other packages or run other commands.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&quot;docker</span> <span class="pre">build</span></code>” command reads the Dockerfile and constructs an image, which consists of binary layers representing the commands in the file. Docker’s layered image structure means that you only need to download the pieces you need. It also means that to optimize build times, it’s a good idea to put those commands that often change later in the file, since during a build, docker will only change rebuild the parts that have changed and anything later than that in the file.</p>
<p>Once a Docker image is created and is available either locally or on dockerhub, you can run it using “<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">run</span> <span class="pre">&lt;image_name&gt;</span></code>”.</p>
<p>The best way to better understand these two basic commands and how to use Dockerfile builds with Python is to walk through our first examples.</p>
<p>The source code for the examples is available in this <a class="reference external" href="https://github.com/CodeSolid/docker-examples">Github repository</a>. It is also downloadable as a zip file. We’ll walk through it all in the sections that follow.</p>
</section>
<section id="running-python-flask-in-a-docker-container">
<h1>Running Python Flask in a Docker Container<a class="headerlink" href="#running-python-flask-in-a-docker-container" title="Link to this heading"></a></h1>
<p>For our first example, let’s see what it takes to run an extremely simple Flask web server application and connect to it from the “host machine” (our computer). The code for this is in the directory, <code class="docutils literal notranslate"><span class="pre">01-docker-flask</span></code>.</p>
<p>The steps we need to walk through are straightforward.</p>
<ul class="simple">
<li><p>We need to select a base docker image to use.</p></li>
<li><p>We need to create a simple “Hello World” flask application file.</p></li>
<li><p>We need to create a Dockerfile that will install Flask together with our application file and run Flask.</p></li>
<li><p>Once we build the image based on the Dockerfile, we need to run it in such a way that we can access it from our desktop.</p></li>
</ul>
</section>
<section id="selecting-a-base-docker-image-for-python">
<h1>Selecting a Base Docker Image for Python<a class="headerlink" href="#selecting-a-base-docker-image-for-python" title="Link to this heading"></a></h1>
<p>The Docker community maintains an extensive array of <a class="reference external" href="https://hub.docker.com/_/python">starter images</a> you can use for Python development. These docker images will generally combine a popular Linux base container with a version of Python, so you’ll be ready to install your code and run it. I usually start from the series of docker images for Python with “slim-buster” in the name. These images have the best combination of reasonably small image size, convenience, and ease of use.</p>
<p>Many in the Docker community like to base their images on Alpine, which is even more lightweight. However, working with Alpine is problematic because things often don’t “just work” out of the box. For example, as I just recently confirmed, assuming you’re logged in to dockerhub, “<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pandas</span></code>” works brilliantly on the image, <code class="docutils literal notranslate"><span class="pre">python:3.10.4-slim-buster</span></code> but fails on <code class="docutils literal notranslate"><span class="pre">python:3.10.4-alpine3.15.</span></code> Therefore, my recommendation for Alpine is to avoid it unless you have a pressing need for it.</p>
<p>Let’s start with our Flask application code, which is very simple as it is based on the <a class="reference external" href="https://flask.palletsprojects.com/en/2.0.x/quickstart/">Flask Quickstart</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># flaskapp.py</span>

<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flask_main</span><span class="p">():</span>
    <span class="k">return</span> <span class="s2">&quot;&lt;h1&gt;Flask is running&lt;/h1&gt;&lt;p&gt;Awesome, that worked.  Now add more code.&lt;/p&gt;&quot;</span>
</pre></div>
</div>
<p>Using Flask means we also need to install it into our environment, so here is the requirements.txt file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">flask</span><span class="o">==</span><span class="mf">2.1.0</span>
</pre></div>
</div>
</section>
<section id="a-simple-flask-dockerfile">
<h1>A Simple Flask Dockerfile<a class="headerlink" href="#a-simple-flask-dockerfile" title="Link to this heading"></a></h1>
<p>With a simple Flask app ready to run, let’s create a Docker image for it. The following is the code for the Dockerfile, which we’ll discuss in detail:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># Dockerfile</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">python:3.10.4-slim-buster</span>
<span class="k">RUN</span><span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>--upgrade<span class="w"> </span>pip

<span class="k">RUN</span><span class="w"> </span>useradd<span class="w"> </span>-m<span class="w"> </span>myuser
<span class="k">USER</span><span class="w"> </span><span class="s">myuser</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/home/myuser</span>

<span class="k">COPY</span><span class="w"> </span>--chown<span class="o">=</span>myuser:myuser<span class="w"> </span>requirements.txt<span class="w"> </span>requirements.txt
<span class="k">COPY</span><span class="w"> </span>--chown<span class="o">=</span>myuser:myuser<span class="w"> </span>flaskapp.py<span class="w"> </span>flaskapp.py
<span class="k">RUN</span><span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>--user<span class="w"> </span>-r<span class="w"> </span>requirements.txt

<span class="k">ENV</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;/home/myuser/.local/bin:</span><span class="si">${</span><span class="nv">PATH</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">ENV</span><span class="w"> </span><span class="nv">FLASK_APP</span><span class="o">=</span>flaskapp
<span class="k">ENV</span><span class="w"> </span><span class="nv">FLASK_RUN_PORT</span><span class="o">=</span><span class="m">8080</span>
<span class="k">ENV</span><span class="w"> </span><span class="nv">FLASK_RUN_HOST</span><span class="o">=</span><span class="m">0</span>.0.0.0

<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;flask&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;run&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>Make sure you name this “Dockerfile” (capitalized) on case-sensitive file systems. Otherwise, the <code class="docutils literal notranslate"><span class="pre">docker</span></code> command won’t automatically find it.</p>
<p>On lines 1-2, we’re specifying the base image that we discussed earlier, then upgrading pip as our first step. “RUN” statements get baked into the image as layers, and the target of the RUN command can be any command that’s valid on the base image. By the way, one way to try things out to see if they’ll work is to interactively run a container based on your base image using this command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>-it<span class="w"> </span>python:3.10.4-slim-buster<span class="w"> </span>/bin/bash
</pre></div>
</div>
<p>This command will launch a bash terminal in a container based on your image so that you can try out commands inside the container. You don’t want to prefix them with “RUN” because RUN is a docker command statement. For example, you can run “<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">&lt;some_package&gt;</span></code>” directly. When you’re done experimenting, type “<code class="docutils literal notranslate"><span class="pre">exit</span></code>” to return to the host terminal prompt.</p>
<p>Returning to the Dockerfile listing, on lines 5-7, we’re adding a user, setting that same user to be the default for any containers that launch, and setting WORKDIR to the user home. From this point on, the other commands in the file will execute in that directory.</p>
<p>Lines 9-10 copy the flaskapp.py and requirements.txt files that we showed earlier to the Docker image, and line 11 installs the requirements.txt file.</p>
<p>Lines 13-16 set up several environment variables to get us ready to run Flask. We set the PATH to refer to “flask” without typing the filename each time. The app name, FLASK_APP, must be set to the name of our Python module. We override the default port and set the FLASK_RUN_HOST to 0.0.0.0 to enable all connections. We need to do this to connect from outside the container, for example, from our host machine. Indeed, it would be a sad web server if we couldn’t connect to it!</p>
</section>
<section id="building-and-running-the-flask-image-and-python-docker-container">
<h1>Building and Running the Flask Image and Python Docker Container<a class="headerlink" href="#building-and-running-the-flask-image-and-python-docker-container" title="Link to this heading"></a></h1>
<p>If you happen to have GNU make on your system, you can use the <a class="reference external" href="https://raw.githubusercontent.com/CodeSolid/docker-examples/main/01-docker-flask/Makefile">Makefile</a> included in the <a class="reference external" href="https://github.com/CodeSolid/docker-examples">source repository</a>, but either way, we need to go over the steps you can use in the terminal and what they mean.</p>
<p><strong>Building the Flask Dockerfile to an Image</strong></p>
<p>Our first step is to build the image from the Dockerfile, so in the directory where that and the rest of the source is, run this command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>build<span class="w"> </span>-t<span class="w"> </span>flask-example:latest<span class="w"> </span>.
</pre></div>
</div>
<p>By default, <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">build</span></code> looks for a file named Dockerfile, so we don’t need to specify that explicitly. The part that reads <code class="docutils literal notranslate"><span class="pre">&quot;-t</span> <span class="pre">flask-example:latest</span></code>” is tagging the image so we can refer to it when running a container based on it. Since when we run an image, Docker will pick “latest” as the version by default, we can generally just call it “flask-example” when we get to that point. Finally, the period sets the local Docker context to the current directory. This is the local directory that Docker uses on the host machine to build the image. It’s why, for example, our COPY commands in the Dockerfile didn’t need a full path.</p>
<p><strong>Running The Flask Container In Docker</strong></p>
<p>Now that we have an image, let’s run the container:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>run<span class="w"> </span>--name<span class="w"> </span>flask<span class="w"> </span>--rm<span class="w"> </span>-d<span class="w"> </span>-p<span class="w"> </span><span class="m">80</span>:8080<span class="w"> </span>flask-example:latest
</pre></div>
</div>
<p>The image name appears at the end of the command, while the “<code class="docutils literal notranslate"><span class="pre">--name</span> <span class="pre">flask</span></code>” gives the running container a name. We can refer to the container by name this way, rather than having to remember the output, a long hexadecimal number representing the ID of the container. The “<code class="docutils literal notranslate"><span class="pre">--rm</span></code>” switch instructs Docker to remove the container once we’re done with it, making this command re-entrant. Remember, we still have the image, so we can run and remove the container as often as we wish. The next switch, “<code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">80:8080</span></code>”, maps our hosts port 80 to port 8080 in the container (8080 was the port we set in the Dockerfile for Flask to listen on). The -d runs the container in detached mode, meaning you won’t see Flask’s output, and you won’t be able to use CTRL-C to stop the container. Detached mode is often what you want, so you can continue to use the terminal for other tasks. However, running without it is sometimes preferable to see the CONSOLE output.</p>
<p>At this point, we can open a browser and navigate to http://localhost to see that it worked.</p>
<p>We should see a page that says “Flask is running” in the header.</p>
<p><strong>Bonus: Running Flask in Docker With Alpine</strong></p>
<p>Above, I mentioned that my strong preference for Docker containers is to use python:<version>-slim-buster. Alpine is pretty fraught with issues for many packages, but for Flask alone, it works without any significant problems with only a few changes:</p>
<ul class="simple">
<li><p>We need <code class="docutils literal notranslate"><span class="pre">adduser</span></code> instead of <code class="docutils literal notranslate"><span class="pre">useradd</span></code> to create a user (fun little minutia, right)?</p></li>
<li><p>A difference many developers forget when they’re trying to connect to the container is that Alpine doesn’t ship with bash, so we need to substitute /bin/sh to open up a shell on a container:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">it</span> <span class="n">flask</span><span class="o">-</span><span class="n">example</span> <span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">sh</span>
</pre></div>
</div>
<p>The source code for the Alpine version of the Flask container we did above is in <a class="reference external" href="https://github.com/CodeSolid/docker-examples/tree/main/02-docker-flask-alpine">02-docker-flask-alpine</a>. The README.md in the root further documents how to use it.</p>
</section>
<section id="running-django-and-postgres-using-docker-compose">
<h1>Running Django and Postgres Using Docker Compose<a class="headerlink" href="#running-django-and-postgres-using-docker-compose" title="Link to this heading"></a></h1>
<p>Docker Compose is another Docker tool that allows you to work with multiple containers simultaneously and relate and network them in interesting ways. Even if you’re using Kubernetes in production, Docker Compose lets you create reproducible application environments where you and other developers on your team can easily deploy applications locally. For example, let’s say you wanted to build one container for your production code and another container based on that image where you install and run the tests for the production code. In that case, you could either use <a class="reference external" href="https://docs.docker.com/develop/develop-images/multistage-build/">Docker multi-stage builds</a> or use Docker Compose to achieve the same result.</p>
<p>A more interesting case where Docker Compose is the preferred method of combining two containers is the one we’ll examine now: combining two levels of a backend stack. One of Django’s major strengths is that it integrates powerful Python data models that provide a high-level abstraction of an underlying SQL database. Django doesn’t exactly force you to use a SQL database, but support for such databases is more tightly integrated than use cases like MongoDB or DyanmoDB. Django also supports database migrations, which allow you to update the structure of the database to reflect the changes to the Python data models in your application.</p>
<p>For development work, it’s sometimes to be able to test out new migrations and other application changes before submitting a pull request and modifying the shared development database. The combination of docker-compose plus Django and our backend database of choice works really well to enable this and other local development tasks on Python/Docker. As a bonus, with a bit of forethought about configuration, we can make our container production-ready as well.</p>
<p>Note that in production, we can still use our Docker container that we developed against our local PostgreSQL database, but by that point, it’s likely that you won’t be running PostgreSQL as a container. That’s perfectly fine as long as we’re able to inject the Postgres configuration into the Django container, and as you’ll see, that’s exactly what we’ll do.</p>
<section id="a-django-and-docker-compose-starter-application">
<h2>A Django And Docker-Compose Starter Application<a class="headerlink" href="#a-django-and-docker-compose-starter-application" title="Link to this heading"></a></h2>
<p>What we’ll build in this article is a Python Django starter application using docker-compose and Postgresql. The goal will be to have a reasonable starting point for future work that has the following features:</p>
<ul class="simple">
<li><p>We can configure both the Postgresql server and the Django application externally in the environment. In that respect, we’re following the configuration guidelines of the Twelve-Factor App.</p></li>
<li><p>To make our application more flexible, we’ll create a basic configuration class to allow for cases where we might later need higher security in non-development environments.</p></li>
<li><p>Other than using Postgresql and connecting to it in our Docker environment, our Django application won’t be opinionated. We began with <code class="docutils literal notranslate"><span class="pre">django-admin</span> <span class="pre">startproject</span></code> and only modified what we needed to get things working. We’ll go over those modifications here.</p></li>
</ul>
<p>The source for this section is located in the <a class="reference external" href="https://github.com/CodeSolid/docker-examples/tree/main/03-docker-compose-django">03-docker-compose-django</a> directory of the examples repository. Before using that source, however, you’ll need to create a secrets file in <code class="docutils literal notranslate"><span class="pre">&lt;repository-root&gt;/secrets/secrets.txt</span></code>. Here’s an example to get you started, but you should modify this, especially the passwords.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">POSTGRES_USER</span><span class="o">=</span>appname
<span class="nv">POSTGRES_PASSWORD</span><span class="o">=</span>appnameKTh1PjVmECYKnZna
<span class="nv">POSTGRES_DB</span><span class="o">=</span>appname_db
<span class="nv">PGDATA</span><span class="o">=</span>/var/lib/postgresql/data/pgdata
<span class="nv">POSTGRES_HOST_AUTH_METHOD</span><span class="o">=</span>md5
<span class="nv">POSTGRES_PORT</span><span class="o">=</span><span class="m">5432</span>
<span class="nv">POSTGRES_REMOTE_HOST</span><span class="o">=</span>backend
<span class="nv">DJANGO_SETTINGS_MODULE</span><span class="o">=</span>codesolid_demo.settings
<span class="nv">DJANGO_SUPERUSER</span><span class="o">=</span>appname_admin
<span class="nv">DJANGO_SUPERUSER_EMAIL</span><span class="o">=</span>your_email@example.com
<span class="nv">DJANGO_SUPERUSER_PASSWORD</span><span class="o">=</span>appnameOtwEgXAAPj5ZLmsQ
<span class="nv">LIFECYCLE</span><span class="o">=</span>dev
</pre></div>
</div>
<p>If you look in the repository root in .gitignore, you’ll see I’ve added the line “secrets,” so nothing in this directory will get checked in. (Other authors will suggest getting it out of the repository tree entirely. Po-TAY-to, po-TAH-to.)</p>
<p>Lines 1-6 of this file are used by default by the PostgreSQL container, meaning that if we select the correct version, we don’t have to modify it. I did run into an issue with more recent versions of PostgreSQL because they’ve changed the default password encryption algorithm from MD5 to SCRAM. I haven’t resolved that issue, so I went back to an earlier version of PostgreSQL for the time being.</p>
<p>The Django configuration relies on the whole file, including the settings that POSTGRESQL is reading. Though the LIFECYCLE key is for future expansion only, we’re not using it yet.</p>
</section>
<section id="a-docker-compose-yaml-file-for-postgres-and-django">
<h2>A docker-compose.yaml file for Postgres and Django<a class="headerlink" href="#a-docker-compose-yaml-file-for-postgres-and-django" title="Link to this heading"></a></h2>
<p>Let’s turn to our docker-compose.yaml file next to see how we can connect Django and Postgres in a single file.</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># docker-compose.yaml</span>
services:
<span class="w">  </span>frontend:
<span class="w">    </span>container_name:<span class="w"> </span>django
<span class="w">    </span>env_file:<span class="w"> </span>../secrets/secrets.txt
<span class="w">    </span>build:<span class="w"> </span>.
<span class="w">    </span>ports:
<span class="w">      </span>-<span class="w"> </span><span class="m">80</span>:8000
<span class="w">  </span>backend:
<span class="w">    </span>env_file:<span class="w"> </span>../secrets/secrets.txt
<span class="w">    </span>image:<span class="w"> </span>postgres:11.15-bullseye
<span class="w">    </span>restart:<span class="w"> </span>always
<span class="w">    </span>volumes:
<span class="w">      </span>-<span class="w"> </span>./data/postgres/pgdata:/var/lib/postgresql/data/pgdata
<span class="w">    </span>ports:<span class="w"> </span>
<span class="w">      </span>-<span class="w"> </span><span class="m">5432</span>:5432
</pre></div>
</div>
<p>As you can see, a docker-compose file is composed of services. One neat thing that docker-compose does by default that you’d otherwise need to configure in docker is setting up networking between the two services. Our two services are named “backend” and “frontend,” but the names are arbitrary. Other examples you’ll see will call them “db” and “web.” Whatever you name them, in a docker-compose service, you can use another service’s name as a hostname and connect to it using that name. That’s why in our secrets file, we have the line, “<code class="docutils literal notranslate"><span class="pre">POSTGRES_REMOTE_HOST=backend</span></code>”; the “backend” is just our docker-compose service name.</p>
<p>We define the frontend service on lines 2-8. We’re using a Dockerfile in the current directory, so we specify that in “build: .” on line 6. In the case of the backend service, we take a different approach and simply name a remote image since we don’t need currently need to customize the Postgresql container at all. If we did, however, we could use something like this instead of line 11:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="w">  </span>build:
<span class="w">      </span>context:<span class="w"> </span>.
<span class="w">      </span>dockerfile:<span class="w"> </span>Dockerfile.db
</pre></div>
</div>
<p>For both services, we’re loading our secrets file into the environment of the container with the line:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span>env_file:<span class="w"> </span>../secrets/secrets.txt
</pre></div>
</div>
<p>We’re also declaring our port mappings for both.</p>
<p>In the case of the backend, we’re mapping the default PostgreSQL data directory to a local directory on lines 13-14. This means that if we don’t delete it (for example, using “make clean”), changes to the database should be persistent.</p>
</section>
<section id="the-django-dockerfile-and-source">
<h2>The Django Dockerfile and Source<a class="headerlink" href="#the-django-dockerfile-and-source" title="Link to this heading"></a></h2>
<p>To create the Django application, we began with a virtual environment with Django installed and used “<code class="docutils literal notranslate"><span class="pre">django</span> <span class="pre">startproject</span> <span class="pre">codesolid_demo</span></code>” as a starting point. (You could use a different application name, of course). From that point, we modified settings.py as follows. First, we imported a function from a custom configuration file we created:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">codesolid_demo.config</span> <span class="kn">import</span> <span class="n">get_config</span>
</pre></div>
</div>
<p>Here is that configuration file:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>
<span class="sd">&quot;&quot;&quot;a somewhat flexible configuration starting point&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">get_config</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a configuration based on a key, from environment (for now).&quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">val</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not found.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span>
</pre></div>
</div>
<p>We wanted to allow for possibly changing how the configuration is loaded in production. We’re loading everything from the environment for now, but perhaps we might need to read from AWS SSM Parameter Store secrets or some other mechanism in a more secure environment. Encapsulating it as a function means we can always change things later if we need to.</p>
<p>Now, inside settings.py, we changed the default SQLite database configuration to the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># settings.py</span>

<span class="c1"># ...</span>

<span class="n">DATABASES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;default&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;ENGINE&#39;</span><span class="p">:</span> <span class="s1">&#39;django.db.backends.postgresql_psycopg2&#39;</span><span class="p">,</span>
        <span class="s1">&#39;NAME&#39;</span><span class="p">:</span> <span class="n">get_config</span><span class="p">(</span><span class="s1">&#39;POSTGRES_DB&#39;</span><span class="p">),</span>
        <span class="s1">&#39;USER&#39;</span><span class="p">:</span> <span class="n">get_config</span><span class="p">(</span><span class="s1">&#39;POSTGRES_USER&#39;</span><span class="p">),</span>
        <span class="s1">&#39;PASSWORD&#39;</span><span class="p">:</span> <span class="n">get_config</span><span class="p">(</span><span class="s1">&#39;POSTGRES_PASSWORD&#39;</span><span class="p">),</span>
        <span class="s1">&#39;HOST&#39;</span><span class="p">:</span> <span class="n">get_config</span><span class="p">(</span><span class="s1">&#39;POSTGRES_REMOTE_HOST&#39;</span><span class="p">),</span>
        <span class="s1">&#39;PORT&#39;</span><span class="p">:</span> <span class="n">get_config</span><span class="p">(</span><span class="s1">&#39;POSTGRES_PORT&#39;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1"># ....</span>
</pre></div>
</div>
<p>As you can see, we’re making heavy use of the environment variable keys we set up in secrets.txt.</p>
<p>With this, our Django application is in pretty good shape, but as you know if you’ve worked with Django, usually we also need to run a database migration from time to time, so let’s do that once before we even start. We also want to create a superuser so we can log in as the admin when Django comes up. Finally, we need to wait for PostgreSQL to be available. Otherwise, we’ll be making database calls too early. We can accomplish all of that in our next section with…</p>
</section>
<section id="some-django-utility-scripts-for-docker">
<h2>Some Django Utility Scripts for Docker<a class="headerlink" href="#some-django-utility-scripts-for-docker" title="Link to this heading"></a></h2>
<p>We have some tasks we need to take care of when our container comes up. For this, we’ll create a shell script and a bit of Python code.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># start.sh</span>

<span class="c1">#!/bin/bash</span>

sleep<span class="w"> </span><span class="m">25</span>
python<span class="w"> </span>manage.py<span class="w"> </span>migrate
python<span class="w"> </span>init.py
python<span class="w"> </span>manage.py<span class="w"> </span>runserver<span class="w"> </span><span class="m">0</span>.0.0.0:8000
</pre></div>
</div>
<p>Our startup script will be called when our container comes up. We start with a short sleep to wait for Postgres to be available. (This perhaps isn’t the most elegant approach, but it’s a good start). Next, we run our database migrations).</p>
<p>Our custom init.py will create a superuser if it doesn’t exist.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># init.py</span>

<span class="sd">&quot;&quot;&quot;Create a superuser if one doesn&#39;t exist&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">django</span>
<span class="kn">from</span> <span class="nn">codesolid_demo.config</span> <span class="kn">import</span> <span class="n">get_config</span>
<span class="kn">from</span> <span class="nn">django.contrib.auth</span> <span class="kn">import</span> <span class="n">get_user_model</span>

<span class="n">django</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
<span class="n">User</span> <span class="o">=</span> <span class="n">get_user_model</span><span class="p">()</span>
<span class="n">superusers</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">is_superuser</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">superusers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">user_name</span> <span class="o">=</span> <span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;DJANGO_SUPERUSER&quot;</span><span class="p">)</span>
    <span class="n">user_email</span> <span class="o">=</span> <span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;DJANGO_SUPERUSER_EMAIL&quot;</span><span class="p">)</span>
    <span class="n">user_password</span> <span class="o">=</span> <span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;DJANGO_SUPERUSER_PASSWORD&quot;</span><span class="p">)</span>
    <span class="n">User</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">create_superuser</span><span class="p">(</span><span class="n">user_name</span><span class="p">,</span> <span class="n">user_email</span><span class="p">,</span> <span class="n">user_password</span><span class="p">)</span>
</pre></div>
</div>
<p>Again we use our custom configuration object here to retrieve the settings we’ve configured for the superuser. If we need to suppress this behavior in other environments, we can always add a check based on looking up the lifecycle, i.e.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">get_config</span><span class="p">(</span><span class="s2">&quot;LIFECYCLE&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, we start Django using the <code class="docutils literal notranslate"><span class="pre">runserver</span></code> command, listening on port 8000.</p>
<p>Finally, let’s take a quick look at our Dockerfile, and then we can get this party started!</p>
</section>
<section id="a-simple-django-dockerfile">
<h2>A Simple Django Dockerfile<a class="headerlink" href="#a-simple-django-dockerfile" title="Link to this heading"></a></h2>
<p>Here’s our Django Dockerfile:</p>
<div class="highlight-docker notranslate"><div class="highlight"><pre><span></span><span class="c"># Dockerfile</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">python:3.10.4-slim-buster</span>
<span class="k">RUN</span><span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>--upgrade<span class="w"> </span>pip

<span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>-y<span class="w"> </span>update
<span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>-y<span class="w"> </span>upgrade
<span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>-y<span class="w"> </span>install<span class="w"> </span>libpq-dev

<span class="k">RUN</span><span class="w"> </span>useradd<span class="w"> </span>-m<span class="w"> </span>myuser
<span class="k">USER</span><span class="w"> </span><span class="s">myuser</span>
<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/home/myuser</span>

<span class="k">COPY</span><span class="w"> </span>--chown<span class="o">=</span>myuser:myuser<span class="w"> </span>requirements.txt<span class="w"> </span>requirements.txt
<span class="k">COPY</span><span class="w"> </span>--chown<span class="o">=</span>myuser:myuser<span class="w"> </span>./codesolid_demo<span class="w"> </span>.
<span class="k">copy</span><span class="w"> </span>--chown<span class="o">=</span>myuser:myuser<span class="w"> </span>start.sh<span class="w"> </span>start.sh
<span class="k">copy</span><span class="w"> </span>--chown<span class="o">=</span>myuser:myuser<span class="w"> </span>init.py<span class="w"> </span>init.py
<span class="k">RUN</span><span class="w"> </span>chmod<span class="w"> </span><span class="m">766</span><span class="w"> </span>init.py
<span class="k">RUN</span><span class="w"> </span>chmod<span class="w"> </span><span class="m">766</span><span class="w"> </span>start.sh
<span class="k">RUN</span><span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>--user<span class="w"> </span>-r<span class="w"> </span>requirements.txt

<span class="k">ENV</span><span class="w"> </span><span class="nv">PATH</span><span class="o">=</span>/home/myuser/.local/bin:<span class="si">${</span><span class="nv">PATH</span><span class="si">}</span>

<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;./start.sh&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>As always, our Python dependencies are in requirements.txt. We’ve seen many of the techniques in this file already, but some of it is new. On lines 5-7, we install a library we may need to ensure our Python PostgreSQL client works correctly. On lines 13-18, we’re installing more necessary files. Finally, on line 23, we’re running our custom shell script to set up and run the server.</p>
</section>
<section id="putting-it-all-together">
<h2>Putting It All Together<a class="headerlink" href="#putting-it-all-together" title="Link to this heading"></a></h2>
<p>At this point, we’re all ready to test things out. Once again, there’s a Makefile in the 03-docker-compose-django directory you can look at, but here’s our command to start PostgreSQL and Django:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>docker<span class="w"> </span>compose<span class="w"> </span>--env-file<span class="w"> </span>../secrets/secrets.txt<span class="w"> </span>up<span class="w"> </span>-d
</pre></div>
</div>
<p>I’m using “docker compose” rather than the separate tool, “docker-compose.” This is available in later versions of docker, but it does essentially the same thing. (I have noticed that you need to match “up” calls and “down” calls using the same method, though). This command, <code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">compose</span> <span class="pre">up</span></code>, builds or downloads any images it needs, sets up a network, and runs the containers for us.</p>
<p>Remember that we were sleeping for a few seconds in our Django start script to let Postgres come up first, but after that, we can try connecting to Django using our browser at http://localhost.</p>
<p><img alt="" src="../../_images/image-1024x7001.png" /></p>
<p>Not only do we have Django up and running, but we’ve run migrations and created our superuser. Let’s confirm that now by navigating to http://localhost/admin. There we can log in using our settings from secrets.txt. Here are the relevant lines from above:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">DJANGO_SUPERUSER</span><span class="o">=</span>appname_admin
<span class="nv">DJANGO_SUPERUSER_PASSWORD</span><span class="o">=</span>appnameOtwEgXAAPj5ZLmsQ
</pre></div>
</div>
<p>Plugging the values from my own secrets file, it looks like this:</p>
<p><img alt="" src="../../_images/image-115.png" /></p>
<p>Clicking login brings me to the Django administration screen:</p>
<p><img alt="" src="../../_images/image-2-1024x6961.png" /></p>
<p>When you’re done working in Django or want to restart due to some changes, simply use the following command to stop the containers you have running:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">compose</span> <span class="n">down</span>
</pre></div>
</div>
</section>
</section>
<section id="more-useful-docker-commands">
<h1>More Useful Docker Commands<a class="headerlink" href="#more-useful-docker-commands" title="Link to this heading"></a></h1>
<p>The commands we’ve discussed so far in this article are just a few of those that are available to you using the “<code class="docutils literal notranslate"><span class="pre">docker</span></code>” client There are several others. For a complete list, you can run the command <code class="docutils literal notranslate"><span class="pre">docker</span></code> on the command line. Then, given any command, you can also learn more by running “<code class="docutils literal notranslate"><span class="pre">docker</span> <span class="pre">&lt;command_name&gt;</span> <span class="pre">--help&quot;</span></code> There is also excellent documentation online.</p>
<p>I would also encourage you to explore the Makefile for the Django section, where the code for the various make targets shows several commands we found helpful in development. For your convenience, however, let me summarize a few of my favorite commands here. Note that several of these are cleanup commands, and you should use them with some caution. Also, these commands should work on most Linux / Mac terminal flavors or in a compatible (bash) Windows terminal (git bash, WSL, etc.).</p>
<table><tbody><tr><td class="has-text-align-left" data-align="left"><strong>Task</strong></td><td><strong>Command Examples</strong></td></tr><tr><td class="has-text-align-left" data-align="left">Connect to a docker-compose service by name</td><td><code>"docker compose run &lt;service_name&gt; /bin/bash</code>"<br>(Most containers)<br>"<code>docker compose run &lt;service_name&gt; /bin/sh</code>"(Alpine containers)</td></tr><tr><td class="has-text-align-left" data-align="left">List all running containers</td><td><code>docker ps</code></td></tr><tr><td class="has-text-align-left" data-align="left">List ALL containers</td><td><code>docker container ls -a</code></td></tr><tr><td class="has-text-align-left" data-align="left">Kill all running containers</td><td><code>docker kill ```docker ps -q```</code></td></tr><tr><td class="has-text-align-left" data-align="left">Delete all containers</td><td><code>docker rm -f ```docker ps -a -q```</code></td></tr><tr><td class="has-text-align-left" data-align="left">Delete all unused (dangling) images and those not referenced by a container without prompting.</td><td><code>docker image prune -a -f</code></td></tr><tr><td class="has-text-align-left" data-align="left">Delete ALL images, used by a container or not, without prompting.</td><td><code>docker image rm -f *</code></td></tr></tbody></table>
<p>Again, for those commands that are deleting images/containers, please exercise caution before using them. I tend to treat all images and containers as something I can rebuild and re-obtain as needed, so when troubleshooting, I reach for a bigger hammer, but this may not be appropriate to your situation.</p>
</section>
<section id="closing-thoughts">
<h1>Closing Thoughts<a class="headerlink" href="#closing-thoughts" title="Link to this heading"></a></h1>
<p>As we mentioned at the start, Docker and Docker Compose add substantial capabilities to the Python developer’s toolkit. Especially when it comes to Docker Compose, the many options for networking, etc. that are available can sometimes make it a bit daunting to configure correctly, but even having not touched it for a while, I was able to stand up the stack in about a day. Because of their declarative syntax, both Docker and Compose are not hard to master. They are effective and accessible tools not only for independent projects but also for team collaboration and releasing software builds that run consistently, regardless of the platform on which they’re deployed.</p>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, John Lockwood.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-QX7KGT4YPE"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-QX7KGT4YPE', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>