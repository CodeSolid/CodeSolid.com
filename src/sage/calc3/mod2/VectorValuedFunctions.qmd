---
jupyter:
  jupytext:
    formats: 'ipynb,qmd'
    text_representation:
      extension: .qmd
      format_name: quarto
      format_version: '1.0'
      jupytext_version: 1.18.1
  kernelspec:
    display_name: SageMath 10.7
    language: sage
    name: sagemath-10.7
---

# Vector Valued Functions

## Section 12.1

From [our text](https://www.contemporarycalculus.com/dh/Calculus_all/CC12_1.pdf), we have:

Definition:  A **vector-valued function** is a rule that assigns a vector to each input number.  Typically a vector-valued function has the form

$$
\begin{align}
\boldsymbol{r(t)} = x(t)i + y(t)j + z(t)k = \boldsymbol{\langle x(t), y(t), z(t)\rangle}
\end{align}
$$

where x, y and z are scalar-valued functions.  

The domain consists of those $t$ in the domain of x, y, and z.

So the range is a collection of vectors.  

Below is an example of a vector valued function plotted in Sage:

```{sage}
t = var('t')
# Define the tuple or vector
r = (cos(t), sin(t), t)

# Use parametric_plot3d for curves
# Syntax: parametric_plot3d( (x, y, z), (variable, start, end) )
parametric_plot3d(r, (t, 0, 6*pi), thickness=2).show(aspect_ratio=(4,4,1))
```

```{sage}
t = var('t')
f1 = 4 - 2*t
f2 = 2 - t
r2 = vector((t, f1, f2))
parametric_plot3d(r2, (t, 0, 2), thickness=2).show()
```

## Limits

The limit of a vector valued function (so it appears) is also a vector:

![](./limits.png)

We can't find such limits directly in sage, but we can write a function to do it easily:

```{sage}
# Do assignment 12.1 with our new function 

t = var('t')
V = vector([4*t^2 - t - 2, (t^2 + 2*t -63)/(t-7), 2*cos(t)])
latex(V)
```

```{sage}
def vvf_limit(fn, v, a):
    """Returns a list with the limit of a vector valued function

    Parameters:  
        fn: The vector, list, or tuple representing the vector valued function
        v:  The variable used in the function
        a:  The "endpoint" or target of the limit, e.g. oo for infinity, 0, etc.

    Returns:
        A list of values with the limit of each component of the function
    """
    l = list(fn)
    return [limit(x, v, a) for x in l]
    
    t = var('t')
r5 = [cos(t), sqrt(4 + t), 3*e**(2*t)]
print(vvf_limit(r5, t, 0))
```

```{sage}
%display plain
t = var('t')
x(t) = 4*t^2 - t -2
y(t) = (t^2 + 2*t -63)/(t-7)
z(t) = 2 * cos(t)
V = [x(t), y(t), z(t)]
print("12.1 question 5")
print(V)
print(vvf_limit(V, t, 7))
print("\n12.1 question 5")
V2 = [2*t^2  + 3*t -1, (t^2 + 2*t -24)/(t-4), 4*cos(t)]
print(V2)
vvf_limit(V2, t, 4)

lim(sin(t)/t, t, 0)
```

## Continutity
A vector valued function $r(t)$ is continuous at $t_0$ if $\lim\limits_{t \to t_0} r(t) = r(t_0)$

```{sage}
# An ellipse and an eliptical helix, comment out one or the other
x = var('x')
# parametric_plot([sin(x), 2*cos(x)], (x, 0, 2*pi))
parametric_plot3d([sin(x), 2*cos(x), x], (x, 0, 8*pi))
```

```{sage}
# Sustitution example:

r5(t) = [cos(t), sqrt(4 + t), 3*e**(2*t)]

print(r5(9), N(r5(9)))
```

```{sage}
# 1. Import the Cylinder shape
from sage.plot.plot3d.shapes import Cylinder
 
# 2. Create the cylinder object: Cylinder(radius, height)
C = Cylinder(1, 2, color='blue', opacity=0.4)
 
# 3. Display the graph
C.show(aspect_ratio=(1,1,1)) 
# aspect_ratio=(1,1,1) ensures the axes are scaled equally, so it looks circular
```

# Section 12.2 - The Derivative of vector-valued functions

The derivative of a vector valued function is simply the derivative of each component, so as in the case of limits, we can implement a function to find one easily in Sage.

```{sage}
def vvf_diff(fn, v, diff_n=1):
    """Returns a list representing the limit of a vector valued function

    Parameters:  
        fn      : The vector, list, or tuple representing the vector valued function
        v       : The variable used in the function
        diff_n  : 1 for first derivative, 2 for second, etc.

    Returns:
        A list of values with the limit of each component of the function
    """
    l = list(fn)
    return [diff(x, v, diff_n) for x in l]
```

```{sage}
# Test out the vvf_diff function

var('x')
V = vector([x^3 + 3*x, ln(x), 5*x + 3])
V_prime = vvf_diff(V, x)
assert  V_prime == [3*x^2 + 3, 1/x, 5]
print(V_prime)
```

```{sage}
# Solve a problem (12.2, q 3):
t = var('t')

print("Problem 12.2, q 3")
V = vector([-3*t^5 - 2, 4*e^(3*t), -5*sin(-3*t)])
print(V)
print(vvf_diff(V, t))

print("\nProblem 12.2, q 4")
V = vector([(-4)/(-t+6), (2*t)/(3*t^2 + 1), (-t^2)/(-7*t^3 - 2)])
print(V)
print(vvf_diff(V, t))

print("\nProblem 12.2, q 5 (second derivative)")
V = vector([6*t + 3*sin(t), 5*t + 6*cos(t)])
print (V)
print(vvf_diff(V, t, 2))
print(vvf_diff(vvf_diff(V, t), t))
```

## Rules and Properties Related to Differentials of Vector Valued Functions

$$
\begin{align}
\begin{array}{|c|c|c|}
\hline
\textbf{Operation} & \textbf{Rule} & \textbf{Result Type} \\
\hline
\text{Sum} & \frac{d}{dt} \left[ \mathbf{r}_1(t) + \mathbf{r}_2(t) \right] = \mathbf{r}_1'(t) + \mathbf{r}_2'(t) & \text{Vector} \\
\hline
\text{Scalar Multiple} & \frac{d}{dt} \left[ c \mathbf{r}(t) \right] = c \mathbf{r}'(t) & \text{Vector} \\
\hline
\text{Product (Dot)} & \frac{d}{dt} \left[ \mathbf{r}_1(t) \cdot \mathbf{r}_2(t) \right] = \mathbf{r}_1'(t) \cdot \mathbf{r}_2(t) + \mathbf{r}_1(t) \cdot \mathbf{r}_2'(t) & \text{Scalar} \\
\hline
\text{Product (Cross)} & \frac{d}{dt} \left[ \mathbf{r}_1(t) \times \mathbf{r}_2(t) \right] = \mathbf{r}_1'(t) \times \mathbf{r}_2(t) + \mathbf{r}_1(t) \times \mathbf{r}_2'(t) & \text{Vector} \\
\hline
\text{Chain Rule} & \frac{d}{dt} \left[ \mathbf{r}(f(t)) \right] = f'(t) \mathbf{r}'(f(t)) & \text{Vector} \\
\hline
\end{array}
\end{align}
$$

## Velocity/Acceleration of Vector Valued Functions

In either $\mathbb{R}^2$ or $\mathbb{R}^3$ if a vector-valued function, $r(t)$ represents the curve of position (e.g. at point $t$), then $v(t) = r^{\prime}(t)$ is the velocity, and $r^{\prime\prime}(t)$ is the acceleration.  The speed is given by the magnitude of the velocity vector, $\|v(t)\|$.

To do this in code, see the following example based on functions we've already defined.

```{sage}
# Find the velocity vector and speed given a position vector
# Our results agree with the example shown in the Video assignment 12.2 Q4, so they are correct,
# but the simplification on the speed value leaves room for improvement.
t = var('t')
pos_vector = vector([cos(pi * t), sin(pi*t), t^2/2])
velocity_vector = vector(vvf_diff(pos_vector, t)) #  Need to wrap list in a vector again for "norm"
acceleration_vector = vvf_diff(pos_vector, t, 2)
speed = velocity_vector.norm().simplify()
print(velocity_vector)
print(acceleration_vector)
print(speed)
```

## The Unit Tangent Vector.

A unit tangent vector for a VVF, $r(t)$ is given by the derivative of the vector over the magnitude of that derivative.  (So it's similar to the formula for a unit vector.)

That is, assuming $r^{\prime}(t) \ne 0$,

$$
\begin{align}
T(t) = \frac{r^{\prime}(t)}{\|r^{\prime}(t)\|}
\end{align}
$$

### Calculating and Plotting a Unit Tangent Vector in SageMath

Let's calculate one for $r(t) = \langle t^3, 2t^2\rangle$, with a tangency point at t = 1.  We get the correct values, but this vector would need to be graphed with the origin at the tangency point, (1,2).  W

```{sage}
# Set up the curve
t = var('t')
r = vector([t**3, 2*t^2])

# Get the derivative, and plug in the point at which we want to draw the unit tangent vector
r_prime = vector(vvf_diff(r, t))
tangency_point = r(t=1)
print("Tangency point: ", tangency_point)

# Calculate the tangent vector using the formula above
tangent_vector = r_prime/r_prime.norm()
print("Tangent vector:", tangent_vector(t=1))

# Get a plot for the curve
plt = parametric_plot(r, (t, .75, 1.4), linestyle="dashed")

# Plot the unit tangent vector.  By setting start equal to our tangency point, we place
# the vector tail where it belongs
plt2 =  plot(tangent_vector(t=1), start=tangency_point, color="red")
plt += plt2                           
plt.show(aspect_ratio=1)
```

## Anti-Derivatives:  Integration of Vector Valued Functions

Given our discussion of limits and derivatives, we might have guessed that the integral of a vector valued function is calculated by taking the integral of each of the components. Thus, for example, given an indefinite integral for $r(t) = \langle f(t), g(t), h(t)\rangle$, then the definite integral is as follows:

$$
\begin{aligned}
\int \mathbf{r}(t) \, dt = \left( \int f(t) \, dt \right) \mathbf{i} + \left( \int g(t) \, dt \right) \mathbf{j} + \left( \int h(t) \, dt \right) \mathbf{k} + \mathbf{C}
\end{aligned}
$$

For the definite integral, we have:
$$
\begin{aligned}
\int_{a}^{b} \mathbf{r}(t) \, dt = \left( \int_{a}^{b} f(t) \, dt \right) \mathbf{i} + \left( \int_{a}^{b} g(t) \, dt \right) \mathbf{j} + \left( \int_{a}^{b} h(t) \, dt \right) \mathbf{k}
\end{aligned}
$$

As we did before for limits and derivatives, we can easily implement this in sage

```{sage}
def vvf_integrate(fn, v, limits=None):
    """Returns a list with the integral of each component of a vector-valued function

    Parameters:  
        fn: The vector, list, or tuple representing the vector valued function
        v:  The variable used in the function
        limits: Either none or a two-element iterable for a definite integral.

    Returns:
        A list of values with the limit of each component of the function

    Notes: 
        Initial condition problems are not yet handled by this function.        
    """
    l = list(fn)
    
    if limits is None:
        return [integrate(x, v) for x in l]
    else:
        return [integrate(x, v, limits[0], limits[1]) for x in l]
    
    t = var('t')
r5 = [cos(t), sqrt(4 + t), 3*e**(2*t)]

# Test it out
print(vvf_integrate(r5, t))
print(vvf_integrate(r5, t, (0, pi/2)))
```

```{sage}
# Solve some problems with it.  Let's start with 12.2, Q6

t = var('t')
r = vector([-4*t^2 + 1, -1*e^(-1 * t), 5 * sin(-4*t)])
print("12.2 Q6", vvf_integrate(r, t))

print("\nAdd initial conditions manually\nto each term for the next problem:")
r = vector([3 + 4*t, cos(t), 6*e^(3*t)])
print("\t12.2 Q7", vvf_integrate(r, t))
```

```{sage}
diff(ln(2*t))
```

```{sage}
# Solving 12.2 Q9.  We're asked to find the angle of 
# intersection between two vectors.  Originally I though we could just 
# use get_angle_between_vectors with respect to the two vectors "as is", 
# but it turns out we needed the angle between the tangent vectors
# of each funciton, so get the derivative first.

# Copied from another notebook -- at some point this needs to be a library!
def get_angle_between_vectors(v: vector, w: vector):
    """returns the angle between two vectors in radians."""
    cos_theta = (v*w)/(v.norm() * w.norm())
    return acos(cos_theta)

r1 = vector([2*t, t^3, -1*t^4])
r2 = vector([sin(-2 * t), sin(2*t), t - pi])

angle_as_fn = get_angle_between_vectors(diff(r1, t), diff(r2, t))
print(N(angle_as_fn(t=0)))
```

## Solving another unit tangent vector problem

Question 12.2 # 10 asks us to find the unit tangent vector at the point $t = 0$ for the function $r(t) = \langle 4t^5 -2, -2 e^{3t}, -2 sin(5t)  \rangle$

Let's do this using the technique we developed earlier:

```{sage}
# Set up the curve
t = var('t')
r = vector([4*t^5 - 2, -2*e^(3*t), -2 * sin(5*t)])
print(r)


# Get the derivative, and plug in the point at which we want to draw the unit tangent vector
r_prime = vector(vvf_diff(r, t))
tangency_point = r(t=0)
print("Tangency point: ", tangency_point)

# Calculate the tangent vector using the formula above
tangent_vector = r_prime/r_prime.norm()
print("Unit tangent vector:", tangent_vector(t=0))
```

## Solving Some Velocity and Acceleration Vector Problems

12.2 question 11:

Given the vector function $\mathbf{r}(t) = \left< -3t, \ -5t^3, \ -t^2 + 5 \right>$

Find the **velocity** and **acceleration** vectors at $t = -2$

In our solution, below, we are finding derivatives as needed using vvf_diff. We don't have a way to substitute into a whole vector (as far as I know), so we use a for comprehension in which we substitute each term to arrive at the correct vector.

```{sage}
t = var('t')
pos = r = vector([-3*t, -5*t^3, -t^2 + 5])
# print(r)

vel = vvf_diff(pos, t)
# print(vel)

accel = vvf_diff(vel, t)
# print(accel)

vel_at_minus_two = [x(t=-2) for x in vel]
accel_at_minus_two = [x(t=-2) for x in accel]

print("velocity at -2", vel_at_minus_two)
print("acceleration at -2", accel_at_minus_two)
```

## Working with Initial Values

Question 12 asks us to find the anti-derivative of the acceleration function given initial condition for both our velocity and acceleration.  Since our ```vvf_integrate``` function doesn't handle initial conditions.

My first attempt at this problem failed, as shown in this [Gemini session](https://gemini.google.com/share/39e29d86177d) where I checked my work.  To solve it correctly, I decided to capture the correct procedure that Gemini used by writing a SageMath function (yes, mine, not Gemini's -- I do *some* thinking here after all).

Here is the problem and the solution:

Find the position vector for a particle with acceleration, initial velocity, and initial position given below.

12.2 Question 12:

$$
\mathbf{a}(t) = \left< 6t, 4\sin(t), \cos(5t) \right>
$$

$$
\mathbf{v}(0) = \left< -3, 4, 3 \right>
$$

$$
\mathbf{r}(0) = \left< 2, -2, 4 \right>
$$

We're asked to find $\mathbf{r}(t)$.


Note, my first attempt at this was rather naive, adding the initial values to each expression.  What's really needed is for each term, $n \in [0,2] $ of the velocity vector, for example:

Solve for $V(t=0) + C_n = intial_values[n]$

```{sage}
# Let's begin with our acceleration vector, 
# integrate it, and "add" the v(0) initial condition as a vector
t = var('t')
A = vector([6*t, 4*sin(t), cos(5*t)])

def vvf_initial_values(vec, variable, init_val, init_val_equals):
    """ Given an integral of a function in vec, returns a function based on initial values.

        This involved solving for the constant of integration for each term.
        
        Parameters:
            vec:           a function representing an indefinite integral of a vector_valued_function
            variable:      the variable we're setting the init_value of
            init_val:      the initial variable
            init_val_equals:  a list of results for the function vec at the init_val

        Returns:
            a vector with the consants of integration adjusted appropriately
    """    
    C = var("C1, C2, C3")

    # Result vector we'll be building.
    init_values_solved = []

    for i in range(0, len(vec)):
        # Start building the term for this "component" of the vector
        # based on subtituting the initial value
        substituted = vec[i](t=init_val)
        
        # Using the result, solve for constant of integration and add it to the 
        # component we're working on.
        val = solve(substituted + C[i] - init_val_equals[i], C[i])[0]
        init_values_solved.append(vec[i] + val.rhs())
        
    return init_values_solved

# Work problem 12.2 # 12

# Integrate the velocity vector, V, then modify it to V_0 based on the initial conditions
V = vector(vvf_integrate(A, t))
print("V: ", V)
V_0 = vvf_initial_values(V, t, 0, [-3, 4, 3])
print("V_0: ", V_0)

# Do the same for the acceleration vector
R = vector(vvf_integrate(V_0, t))
print("R: ", R)
R_0 = vvf_initial_values(R, t, 0, [2, -2, 4])
print("R_0: ", R_0)

print("At this point R_0 contains our final answer.")
```

